[{"title":"快速掌握Markdown，学不会你砍死我（胎教级）","url":"/2023/08/04/Markdown/","content":"Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。使用Markdown 编写的文档可以轻松地导出为 HTML、Word、图像、PDF、Epub 等多种格式的文档。当前许多网站都支持使用 Markdown 来撰写文档或者发表文章。\n\n新手教程先请大家看一张简单的动图。\n\n有没有觉得很amazing？你只是在纯打字，按下换行的瞬间，没做任何操作，文本就自动拥有了美观的格式，左侧的【大纲】栏还自动生成了文章目录，整个过程美观又省心。\n\na. 列全文粗纲-用标题样式在文本前输入：# + 空格。一个井号代表一级标题，两个井号二级标题，以此类推，一共可以到六级:\n一级标题  （# 一级标题）二级标题  （## 二级标题）三级标题  （### 三级标题）四级标题  （#### 四级标题）五级标题 （##### 五级标题）六级标题  （###### 六级标题）b. 写正文细纲-用列表样式我们可以通过分点陈列的方式来写一段正文的细纲，也就是使用“列表”格式，请在文本前输入：+ 和 空格：\n\n这是我的第一个观点 （在此处，我输入的内容为：+ 这是我的第一个观点 ）\n这是我的第二个观点\n这是我的第三个观点\n这是我第三个观点中的分论点一\n这是我第三个观点中的分论点二\n……\n\n\n\n可以看到，如果你的细纲还分多个层级，那就打多级列表，也就是在回车键换行之后再按个Tab键，那这一行列表就会自动缩进一个空格。打完后，想要退回上一级就按Shift+Tab健，退出列表则仍然是按多次回车键：\n如果你想这个列表是有序的，那就将“+”号替换成“1.”，即在文本前输入：1. + 空格，后续操作与上方的无序列表一样：\n\n第一个有序观点 （在此处，我输入的内容为：1. 第一个有序观点 ）\n第二个有序观点\n第三个有序观点\n\nc. 突出重点字词-用加粗、加斜样式写正文时，我们经常需要突出重点，也就是加粗加斜，这时，只需把重点内容包在两个星号（*）或者一个星号（）中：\n\n比如，当我输入**想要加粗的内容** \n显示效果： 想要加粗的内容\n当我输入*想要加斜的内容*\n显示效果：想要加斜的内容\n\nd.  突出重点段落-用引用格式如果你想突出的是一个段落，那可以打一个像我上面这样，左边有一条线的文本格式，也就是“引用”格式。这需要在文本前输入：&gt; + 空格:\n\n比如这样 （此处，我输入的内容为： &gt; 比如这样）\n\ne. 划分文章结构-用分割线样式写完一部分后，我们可以加条分割线，使文章内容在视觉上结构更分明。这时，只需在单独的一行空行开头打上：—，这样三个短杠\n\n输入—\n\n输出效果：\n\n自此，新手阶段结束，相信通过这几个例子你应该能明白Markdown文本怎么写了，平时写作时一般这几个格式也就够用了。\n如果你觉得这些还不够，还想学更多招式，比如表格、添加图片、添加超链接等，那就请接着往下看。\n进阶扩展Markdown 链接语法链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。\n超链接Markdown语法代码：[超链接显示名](超链接地址 &quot;超链接标题&quot;)\n显示效果：\n这是一个链接 Markdown语法\n\n给链接增加 Title（标题）链接title是当鼠标悬停在链接上时会出现的文字，这个title是可选的，它放在圆括号中链接地址后面，跟链接地址之间以空格分隔。\n\n 这是一个链接 [Markdown语法](https://markdown.com.cn &quot;最好的markdown教程&quot;)。  \n显示效果：\n这是一个链接 Markdown语法\n将鼠标分别移动到上面两处蓝色字体，看看有什么区别吧！\n网址和Email地址使用尖括号可以很方便地把URL或者email地址变成可点击的链接\n&lt;https://markdown.com.cn&gt;&lt;fake@example.com&gt;\n显示效果：https://markdown.com.cn&#102;&#x61;&#x6b;&#x65;&#x40;&#101;&#x78;&#97;&#x6d;&#112;&#108;&#101;&#46;&#99;&#111;&#109;\n图片语法要添加图像，请使用感叹号 (!), 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。\n如你所见，本篇文档最开始就引入了一张图片\n它的具体实现效果是这样的的\n插入图片Markdown语法代码：![图片alt](图片链接 &quot;图片title&quot;)\n比如：![这是图片](https://cdn.staticaly.com/gh/xiaoshizhang/picx-images-hosting@master/こっち向きのダックスフンド.kqyq3shm8ps.webp &quot;dog&quot;)\n显示效果：\n\n不同语法的代码块Markdown代码块可以通过在代码文本前后加入反引号（`），或使用三个连续的反引号（```）作为代码块的开头和结尾。下面以Python语言为例子：\n输入的内容为：\n显示效果：\ndef hello_world():    print(&quot;Hello World!&quot;)\n其他语言在此不赘述了，要改的只是“python”这一段。\n到这里，Markdown已经基本介绍完了，剩下的就是转义字符语法和内嵌HTML标签，还有些扩展语法，但笔者觉得这两些使用频率都不高，就留给大家自行掌握吧，现在放出Markdown的官方教程链接，供大家查缺补漏。\n基础语法：https://markdown.com.cn/basic-syntax/\n扩展语法：https://markdown.com.cn/extended-syntax/\n真心希望这篇文章能帮助各位，笔者参上。\n2023年8月4日\n","tags":["教程","Markdown"]},{"title":"域名备案终于通过了","url":"/2023/08/14/beian/","content":"为了规范互联网信息服务活动，促进互联网信息服务健康有序发展，根据国务院令第 292 号《互联网信息服务管理办法》和信息产业部令第 33 号《非经营性互联网信息服务备案管理办法》规定，国家对经营性互联网信息服务实行许可制度，对非经营性互联网信息服务实行备案制度。未取得许可或者未履行备案手续的，不得从事互联网信息服务，否则就属于违法行为。\n\n备案后处理说明网站备案成功后，您需要在网站底部添加网站备案号和跳转至工信部，以便网站访问者查询与确认网站备案信息，部分省份还需要在网站底部添加版权所有。若网站涉及经营性业务，您需在网站备案后申请经营性 ICP 许可证，并且需在网站开通（即网站对外提供访问服务）之日起30日内向 全国公安机关互联网站安全管理服务平台 提交公安联网备案申请。\n网站添加网站备案号网站备案成功后，您需要在备案成功的网站底部悬挂工信部下发的网站备案号，并生成链接指向工信部网站https://beian.miit.gov.cn，提供网站访问者查询核对。若您未在网站底部添加网站备案号，将被备案所在省通信管理局责令改正，并处五千元以上一万元以下罚款。\n不多说了，我去捣鼓之后的事情了。\n","tags":["备案"]},{"title":"阅《诡秘之主》有感","url":"/2023/08/09/guimi/","content":"向现实靠拢是近期网络文学的重要发展方向，在现实主义题材佳作频现的同时，玄幻类小说也在持续开掘现实叙事的空间。爱潜水的乌贼所创作的《诡秘之主》正是兼具飞扬的想象张力和成熟的现实内核的优秀作品。\n\n写在一切之前2020年5月1日，爱潜水的乌贼 （下文简称乌贼） 在起点中文网上发布《诡秘之主》的最终篇——《新的旅程》，为这部领跑2019年中国原创文学风云榜男频TOP10，且屡次打破推荐榜、月票榜纪录的玄幻巨著画上句号。\n然而自从它上架开始就伴随着的热议，至今仍未冷却。对人物命运的讨论，对作者思路的揣测，乃至各种同人文、漫画、广播剧的创作，仍然是众多书友最为津津乐道的话题。\n不少读者甚至开始漫长的二刷、三刷，只为在捕捉细节的同时，再度体验那交织着现实与人性的玄幻之旅。\n近年来，在政府的政策导向、平台的积极宣传，以及众多写手笔耕不辍的探索下，现实主义题材的优秀网络文学作品接连涌现。\n有以国企复兴为主题，荣获网络文学原创现实主义征文大赛特等奖的《复兴之路》；有小中见大，以个人命运反映我国四十年来重工业发展宏图的《大国重工》；有以爱情为主线连接山区支教与军旅题材的《明月度关山》。除此之外，还有《繁花》《长夜难明》《网络英雄传》系列等作品，充分彰显出网络小说贴近现实、反映现实最终超越现实的张力和活力。\n这些彰显着崭新特质的现实主义小说证明了网文正通过自己的方式干预现实，而它们在书写崭新篇章的同时，也向网文批评家抛出新的命题，那就是玄幻小说如何反映现实。\n玄幻是网络文学萌芽、发展阶段的重要题材，而在大多数人眼中，玄幻小说正是为了远离现实生活而构筑的空中楼阁，多玄虚而少真实，多笑谑而少批判。\n然而，真正具有文学价值、审美价值的玄幻作品，正是以现实生活为想象根基，以大众的喜怒哀乐为情感脉络，以普世的人道主义精神和价值观念为文化核心。\n许多为人称道的玄幻作品通过不懈的探索实践，向现实搭建交汇的桥梁。\n出现了充斥着金庸武侠的江湖风、以融合佛道思想为内核的《牧神记》；\n框架宏大却不失人世细腻真实的《剑来》；\n人物刻画出彩、字里行间透出古典元素的《元尊》等。\n它们在文字、风格、情节、内涵等多重小说领域均有所创新突破，同时在某些方面也不可避免地存在短板。\n而堪称集大成者，且更迈前一步的，正是《诡秘之主》这部扎根于英国维多利亚时期，拥有克苏鲁旧神体系、SCP基金会、蒸汽朋克、神秘学等多重世界观的玄幻作品。\n","tags":["网络小说"]},{"title":"凡人修仙，风云再起！","url":"/2023/08/03/fanren/","content":"时隔这么些年，凡人修仙传的动漫终于更新了，这波爷关更，带来了更加精彩的剧情。谨慎稳健的韩立为了躲避极阴岛的追查，曲魂结丹四年后才回到起点收拾行囊准备出海，喜得贵虫，不愧是韩立！结丹去（大声）！\n\n\n越来越好的剧情画面，我们的凡人正在蒸蒸日上~刚开始还肉眼可见的卡顿，到了现在，凡人修仙传已然成为一部成熟的动漫，制作水准也一直在稳步提升。\n这才是我们所期待的凡人。\n兢兢业业的韩老魔凭借熟练的杀鱼手法和十年如一日的坚持成为大润发本年度最佳员工。\n作为观众，堵塞了一年的念头终于通达了。\n奉上连接，都给我…去看！\n凡人修仙传动漫\n","tags":["国产动漫"]},{"title":"你好，世界","url":"/2023/08/02/hello-world/","content":"欢迎来到我的个人博客，在这里，你可以哼哼哼啊啊啊啊啊，看到一些有趣的内容，当然，我并不确保这些东西对你有帮助。\n\n\n快速开始如何建立一个新帖？$ hexo new &quot;My New Post&quot;\n\n更多详情: Writing\n运行服务$ hexo server\n\n更多详情: Server\n生成静态文件$ hexo generate\n\n更多详情: Generating\n部署到远程站点$ hexo deploy\n\n更多详情: Deployment\n"},{"title":"从零开始学JavaScript（001 导论）","url":"/2023/08/17/js001/","content":"在运维个人博客的过程中，发现主题中很多功能还是需要掌握一定程度的JavaScript，于是乎，就有了这个系列。不管怎么说，先让我们了解一下JavaScript吧！\n\n1.什么是JavaScript语言？JavaScript 是一种轻量级的脚本语言。所谓“脚本语言”（script language），指的是它不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本”。\nJavaScript 也是一种嵌入式（embedded）语言。它本身提供的核心语法不算很多，只能用来做一些数学和逻辑运算。JavaScript 本身不提供任何与 I&#x2F;O（输入&#x2F;输出）相关的 API，都要靠宿主环境（host）提供，所以 JavaScript 只合适嵌入更大型的应用程序环境，去调用宿主环境提供的底层 API。\n目前，已经嵌入 JavaScript 的宿主环境有多种，最常见的环境就是浏览器，另外还有服务器环境，也就是 Node 项目。\n从语法角度看，JavaScript 语言是一种“对象模型”语言。各种宿主环境通过这个模型，描述自己的功能和操作接口，从而通过 JavaScript 控制这些功能。但是，JavaScript 并不是纯粹的“面向对象语言”，还支持其他编程范式（比如函数式编程）。这导致几乎任何一个问题，JavaScript 都有多种解决方法。阅读本书的过程中，你会诧异于 JavaScript 语法的灵活性。\nJavaScript 的核心语法部分相当精简，只包括两个部分：基本的语法构造（比如操作符、控制结构、语句）和标准库（就是一系列具有各种功能的对象比如Array、Date、Math等）。除此之外，各种宿主环境提供额外的 API（即只能在该环境使用的接口），以便 JavaScript 调用。以浏览器为例，它提供的额外 API 可以分成三大类——\n\n浏览器控制类：操作浏览器\nDOM 类：操作网页的各种元素\nWeb 类：实现互联网的各种功能\n\n如果宿主环境是服务器，则会提供各种操作系统的 API，比如文件操作 API、网络通信 API等等。这些你都可以在 Node 环境中找到。\n本书主要介绍 JavaScript 核心语法和浏览器网页开发的基本知识，不涉及 Node。全书可以分成以下四大部分。\n\n基本语法\n标准库\n浏览器 API\nDOM\n\n2.为什么要学习JavaScript呢？JavaScript 语言有一些显著特点，使得它非常值得学习。它既适合作为学习编程的入门语言，也适合当作日常开发的工作语言。它是目前最有希望、前途最光明的计算机语言之一。\n2.1操控浏览器的能力JavaScript 的发明目的，就是作为浏览器的内置脚本语言，为网页开发者提供操控浏览器的能力。它是目前唯一一种通用的浏览器脚本语言，所有浏览器都支持。它可以让网页呈现各种特殊效果，为用户提供良好的互动体验。\n目前，全世界几乎所有网页都使用 JavaScript。如果不用，网站的易用性和使用效率将大打折扣，无法成为操作便利、对用户友好的网站。\n对于一个互联网开发者来说，如果你想提供漂亮的网页、令用户满意的上网体验、各种基于浏览器的便捷功能、前后端之间紧密高效的联系，JavaScript 是必不可少的工具。\n2.2广泛的使用领域近年来，JavaScript 的使用范围，慢慢超越了浏览器，正在向通用的系统语言发展。\n（1）浏览器的平台化随着 HTML5 的出现，浏览器本身的功能越来越强，不再仅仅能浏览网页，而是越来越像一个平台，JavaScript 因此得以调用许多系统功能，比如操作本地文件、操作图片、调用摄像头和麦克风等等。这使得 JavaScript 可以完成许多以前无法想象的事情。\n（2）NodeNode 项目使得 JavaScript 可以用于开发服务器端的大型项目，网站的前后端都用 JavaScript 开发已经成为了现实。有些嵌入式平台（Raspberry Pi）能够安装 Node，于是 JavaScript 就能为这些平台开发应用程序。\n（3）数据库操作JavaScript 甚至也可以用来操作数据库。NoSQL 数据库这个概念，本身就是在 JSON（JavaScript Object Notation）格式的基础上诞生的，大部分 NoSQL 数据库允许 JavaScript 直接操作。基于 SQL 语言的开源数据库 PostgreSQL 支持 JavaScript 作为操作语言，可以部分取代 SQL 查询语言。\n（4）移动平台开发JavaScript 也正在成为手机应用的开发语言。一般来说，安卓平台使用 Java 语言开发，iOS 平台使用 Objective-C 或 Swift 语言开发。许多人正在努力，让 JavaScript 成为各个平台的通用开发语言。\nPhoneGap 项目就是将 JavaScript 和 HTML5 打包在一个容器之中，使得它能同时在 iOS 和安卓上运行。Facebook 公司的 React Native 项目则是将 JavaScript 写的组件，编译成原生组件，从而使它们具备优秀的性能。\nMozilla 基金会的手机操作系统 Firefox OS，更是直接将 JavaScript 作为操作系统的平台语言，但是很可惜这个项目没有成功。\n（5）内嵌脚本语言越来越多的应用程序，将 JavaScript 作为内嵌的脚本语言，比如 Adobe 公司的著名 PDF 阅读器 Acrobat、Linux 桌面环境 GNOME 3。\n（6）跨平台的桌面应用程序Chromium OS、Windows 8 等操作系统直接支持 JavaScript 编写应用程序。Mozilla 的 Open Web Apps 项目、Google 的 Chrome App 项目、GitHub 的 Electron 项目、以及 TideSDK 项目，都可以用来编写运行于 Windows、Mac OS 和 Android 等多个桌面平台的程序，不依赖浏览器。\n（7）小结可以预期，JavaScript 最终将能让你只用一种语言，就开发出适应不同平台（包括桌面端、服务器端、手机端）的程序。早在2013年9月的统计之中，JavaScript 就是当年 GitHub 上使用量排名第一的语言。\n著名程序员 Jeff Atwood 甚至提出了一条 “Atwood 定律”：\n“所有可以用 JavaScript 编写的程序，最终都会出现 JavaScript 的版本。”(Any application that can be written in JavaScript will eventually be written in JavaScript.)\n2.3 易学性相比学习其他语言，学习 JavaScript 有一些有利条件。\n（1）学习环境无处不在只要有浏览器，就能运行 JavaScript 程序；只要有文本编辑器，就能编写 JavaScript 程序。这意味着，几乎所有电脑都原生提供 JavaScript 学习环境，不用另行安装复杂的 IDE（集成开发环境）和编译器。\n（2）简单性相比其他脚本语言（比如 Python 或 Ruby），JavaScript 的语法相对简单一些，本身的语法特性并不是特别多。而且，那些语法中的复杂部分，也不是必需要学会。你完全可以只用简单命令，完成大部分的操作。\n（3）与主流语言的相似性JavaScript 的语法很类似 C&#x2F;C++ 和 Java，如果学过这些语言（事实上大多数学校都教），JavaScript 的入门会非常容易。\n必须说明的是，虽然核心语法不难，但是 JavaScript 的复杂性体现在另外两个方面。\n首先，它涉及大量的外部 API。JavaScript 要发挥作用，必须与其他组件配合，这些外部组件五花八门，数量极其庞大，几乎涉及网络应用的各个方面，掌握它们绝非易事。\n其次，JavaScript 语言有一些设计缺陷。某些地方相当不合理，另一些地方则会出现怪异的运行结果。学习 JavaScript，很大一部分时间是用来搞清楚哪些地方有陷阱。Douglas Crockford 写过一本有名的书，名字就叫《JavaScript: The Good Parts》，言下之意就是这门语言不好的地方很多，必须写一本书才能讲清楚。另外一些程序员则感到，为了更合理地编写 JavaScript 程序，就不能用 JavaScript 来写，而必须发明新的语言，比如 CoffeeScript、TypeScript、Dart 这些新语言的发明目的，多多少少都有这个因素。\n尽管如此，目前看来，JavaScript 的地位还是无法动摇。加之，语言标准的快速进化，使得 JavaScript 功能日益增强，而语法缺陷和怪异之处得到了弥补。所以，JavaScript 还是值得学习，况且它的入门真的不难。\n2.4 强大的性能JavaScript 的性能优势体现在以下方面。\n（1）灵活的语法，表达力强。JavaScript 既支持类似 C 语言清晰的过程式编程，也支持灵活的函数式编程，可以用来写并发处理（concurrent）。这些语法特性已经被证明非常强大，可以用于许多场合，尤其适用异步编程。\nJavaScript 的所有值都是对象，这为程序员提供了灵活性和便利性。因为你可以很方便地、按照需要随时创造数据结构，不用进行麻烦的预定义。\nJavaScript 的标准还在快速进化中，并不断合理化，添加更适用的语法特性。\n（2）支持编译运行。JavaScript 语言本身，虽然是一种解释型语言，但是在现代浏览器中，JavaScript 都是编译后运行。程序会被高度优化，运行效率接近二进制程序。而且，JavaScript 引擎正在快速发展，性能将越来越好。\n此外，还有一种 WebAssembly 格式，它是 JavaScript 引擎的中间码格式，全部都是二进制代码。由于跳过了编译步骤，可以达到接近原生二进制代码的运行速度。各种语言（主要是 C 和 C++）通过编译成 WebAssembly，就可以在浏览器里面运行。\n（3）事件驱动和非阻塞式设计。JavaScript 程序可以采用事件驱动（event-driven）和非阻塞式（non-blocking）设计，在服务器端适合高并发环境，普通的硬件就可以承受很大的访问量。\n2.5 开放性JavaScript 是一种开放的语言。它的标准 ECMA-262 是 ISO 国际标准，写得非常详尽明确；该标准的主要实现（比如 V8 和 SpiderMonkey 引擎）都是开放的，而且质量很高。这保证了这门语言不属于任何公司或个人，不存在版权和专利的问题。\n语言标准由 TC39 委员会负责制定，该委员会的运作是透明的，所有讨论都是开放的，会议记录都会对外公布。\n不同公司的 JavaScript 运行环境，兼容性很好，程序不做调整或只做很小的调整，就能在所有浏览器上运行。\n2.6 社区支持和就业机会全世界程序员都在使用 JavaScript，它有着极大的社区、广泛的文献和图书、丰富的代码资源。绝大部分你需要用到的功能，都有多个开源函数库可供选用。\n作为项目负责人，你不难招聘到数量众多的 JavaScript 程序员；作为开发者，你也不难找到一份 JavaScript 的工作。\n实验环境推荐安装 Chrome 浏览器，它的“开发者工具”（Developer Tools）里面的“控制台”（console），就是运行 JavaScript 代码的理想环境。\n进入 Chrome 浏览器的“控制台”，有两种方法。\n\n直接进入：按下Option + Command + J（Mac）或者Ctrl + Shift + J（Windows &#x2F; Linux）\n\n开发者工具进入：开发者工具的快捷键是 F12，或者Option + Command + I（Mac）以及Ctrl + Shift + I（Windows &#x2F; Linux），然后选择 Console 面板\n\n\n进入控制台以后，就可以在提示符后输入代码，然后按Enter键，代码就会执行。如果按Shift + Enter键，就是代码换行，不会触发执行。建议阅读本教程时，将代码复制到控制台进行实验。\n作为尝试，你可以将下面的程序复制到“控制台”，按下回车后，就可以看到运行结果。\nfunction greetMe(yourName) &#123;  console.log(&#x27;Hello &#x27; + yourName);&#125;greetMe(&#x27;World&#x27;)// Hello World\n\n\n未完待续\n","tags":["教程","JavaScript"]},{"title":"从零开始学JavaScript（002 语言的历史）","url":"/2023/08/17/js002/","content":"JavaScript 因为互联网而生，紧跟着浏览器的出现而问世。回顾它的历史，就要从浏览器的历史讲起。\n\n1. 诞生1990年底，欧洲核能研究组织（CERN）科学家 Tim Berners-Lee，在全世界最大的电脑网络——互联网的基础上，发明了万维网（World Wide Web），从此可以在网上浏览网页文件。最早的网页只能在操作系统的终端里浏览，也就是说只能使用命令行操作，网页都是在字符窗口中显示，这当然非常不方便。\n1992年底，美国国家超级电脑应用中心（NCSA）开始开发一个独立的浏览器，叫做 Mosaic。这是人类历史上第一个浏览器，从此网页可以在图形界面的窗口浏览。\n1994年10月，NCSA 的一个主要程序员 Marc Andreessen 联合风险投资家 Jim Clark，成立了 Mosaic 通信公司（Mosaic Communications），不久后改名为 Netscape。这家公司的方向，就是在 Mosaic 的基础上，开发面向普通用户的新一代的浏览器 Netscape Navigator。\n1994年12月，Navigator 发布了1.0版，市场份额一举超过90%。\nNetscape 公司很快发现，Navigator 浏览器需要一种可以嵌入网页的脚本语言，用来控制浏览器行为。当时，网速很慢而且上网费很贵，有些操作不宜在服务器端完成。比如，如果用户忘记填写“用户名”，就点了“发送”按钮，到服务器再发现这一点就有点太晚了，最好能在用户发出数据之前，就告诉用户“请填写用户名”。这就需要在网页中嵌入小程序，让浏览器检查每一栏是否都填写了。\n管理层对这种浏览器脚本语言的设想是：功能不需要太强，语法较为简单，容易学习和部署。那一年，正逢 Sun 公司的 Java 语言问世，市场推广活动非常成功。Netscape 公司决定与 Sun 公司合作，浏览器支持嵌入 Java 小程序（后来称为 Java applet）。但是，浏览器脚本语言是否就选用 Java，则存在争论。后来，还是决定不使用 Java，因为网页小程序不需要 Java 这么“重”的语法。但是，同时也决定脚本语言的语法要接近 Java，并且可以支持 Java 程序。这些设想直接排除了使用现存语言，比如 Perl、Python 和 TCL。\n1995年，Netscape 公司雇佣了程序员 Brendan Eich 开发这种网页脚本语言。Brendan Eich 有很强的函数式编程背景，希望以 Scheme 语言（函数式语言鼻祖 LISP 语言的一种方言）为蓝本，实现这种新语言。\n1995年5月，Brendan Eich 只用了10天，就设计完成了这种语言的第一版。它是一个大杂烩，语法有多个来源。\n\n基本语法：借鉴 C 语言和 Java 语言。\n数据结构：借鉴 Java 语言，包括将值分成原始值和对象两大类。\n函数的用法：借鉴 Scheme 语言和 Awk 语言，将函数当作第一等公民，并引入闭包。\n原型继承模型：借鉴 Self 语言（Smalltalk 的一种变种）。\n正则表达式：借鉴 Perl 语言。\n字符串和数组处理：借鉴 Python 语言。\n\n为了保持简单，这种脚本语言缺少一些关键的功能，比如块级作用域、模块、子类型（subtyping）等等，但是可以利用现有功能找出解决办法。这种功能的不足，直接导致了后来 JavaScript 的一个显著特点：对于其他语言，你需要学习语言的各种功能，而对于 JavaScript，你常常需要学习各种解决问题的模式。而且由于来源多样，从一开始就注定，JavaScript 的编程风格是函数式编程和面向对象编程的一种混合体。\nNetscape 公司的这种浏览器脚本语言，最初名字叫做 Mocha，1995年9月改为 LiveScript。12月，Netscape 公司与 Sun 公司（Java 语言的发明者和所有者）达成协议，后者允许将这种语言叫做 JavaScript。这样一来，Netscape 公司可以借助 Java 语言的声势，而 Sun 公司则将自己的影响力扩展到了浏览器。\n之所以起这个名字，并不是因为 JavaScript 本身与 Java 语言有多么深的关系（事实上，两者关系并不深，详见下节），而是因为 Netscape 公司已经决定，使用 Java 语言开发网络应用程序，JavaScript 可以像胶水一样，将各个部分连接起来。当然，后来的历史是 Java 语言的浏览器插件失败了，JavaScript 反而发扬光大。\n1995年12月4日，Netscape 公司与 Sun 公司联合发布了 JavaScript 语言，对外宣传 JavaScript 是 Java 的补充，属于轻量级的 Java，专门用来操作网页。\n1996年3月，Navigator 2.0 浏览器正式内置了 JavaScript 脚本语言。\n2. JavaScript 与 Java 的关系这里专门说一下 JavaScript 和 Java 的关系。它们是两种不一样的语言，但是彼此存在联系。\nJavaScript 的基本语法和对象体系，是模仿 Java 而设计的。但是，JavaScript 没有采用 Java 的静态类型。正是因为 JavaScript 与 Java 有很大的相似性，所以这门语言才从一开始的 LiveScript 改名为 JavaScript。基本上，JavaScript 这个名字的原意是“很像Java的脚本语言”。\nJavaScript 语言的函数是一种独立的数据类型，以及采用基于原型对象（prototype）的继承链。这是它与 Java 语法最大的两点区别。JavaScript 语法要比 Java 自由得多。\n另外，Java 语言需要编译，而 JavaScript 语言则是运行时由解释器直接执行。\n总之，JavaScript 的原始设计目标是一种小型的、简单的动态语言，与 Java 有足够的相似性，使得使用者（尤其是 Java 程序员）可以快速上手。\n3. JavaScript 与 ECMAScript 的关系1996年8月，微软模仿 JavaScript 开发了一种相近的语言，取名为JScript（JavaScript 是 Netscape 的注册商标，微软不能用），首先内置于IE 3.0。Netscape 公司面临丧失浏览器脚本语言的主导权的局面。\n1996年11月，Netscape 公司决定将 JavaScript 提交给国际标准化组织 ECMA（European Computer Manufacturers Association），希望 JavaScript 能够成为国际标准，以此抵抗微软。ECMA 的39号技术委员会（Technical Committee 39）负责制定和审核这个标准，成员由业内的大公司派出的工程师组成，目前共25个人。该委员会定期开会，所有的邮件讨论和会议记录，都是公开的。\n1997年7月，ECMA 组织发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript。这个版本就是 ECMAScript 1.0 版。之所以不叫 JavaScript，一方面是由于商标的关系，Java 是 Sun 公司的商标，根据一份授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 已经被 Netscape 公司注册为商标，另一方面也是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。在日常场合，这两个词是可以互换的。\nECMAScript 只用来标准化 JavaScript 这种语言的基本语法结构，与部署环境相关的标准都由其他标准规定，比如 DOM 的标准就是由 W3C组织（World Wide Web Consortium）制定的。\nECMA-262 标准后来也被另一个国际标准化组织 ISO（International Organization for Standardization）批准，标准号是 ISO-16262。\n4. JavaScript 的版本1997年7月，ECMAScript 1.0发布。\n1998年6月，ECMAScript 2.0版发布。\n1999年12月，ECMAScript 3.0版发布，成为 JavaScript 的通行标准，得到了广泛支持。\n2007年10月，ECMAScript 4.0版草案发布，对3.0版做了大幅升级，预计次年8月发布正式版本。草案发布后，由于4.0版的目标过于激进，各方对于是否通过这个标准，发生了严重分歧。以 Yahoo、Microsoft、Google 为首的大公司，反对 JavaScript 的大幅升级，主张小幅改动；以 JavaScript 创造者 Brendan Eich 为首的 Mozilla 公司，则坚持当前的草案。\n2008年7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激进，ECMA 开会决定，中止 ECMAScript 4.0 的开发（即废除了这个版本），将其中涉及现有功能改善的一小部分，发布为 ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为 Harmony（和谐）。会后不久，ECMAScript 3.1 就改名为 ECMAScript 5。\n2009年12月，ECMAScript 5.0版 正式发布。Harmony 项目则一分为二，一些较为可行的设想定名为 JavaScript.next 继续开发，后来演变成 ECMAScript 6；一些不是很成熟的设想，则被视为 JavaScript.next.next，在更远的将来再考虑推出。TC39 的总体考虑是，ECMAScript 5 与 ECMAScript 3 基本保持兼容，较大的语法修正和新功能加入，将由 JavaScript.next 完成。当时，JavaScript.next 指的是ECMAScript 6。第六版发布以后，将指 ECMAScript 7。TC39 预计，ECMAScript 5 会在2013年的年中成为 JavaScript 开发的主流标准，并在此后五年中一直保持这个位置。\n2011年6月，ECMAScript 5.1版发布，并且成为 ISO 国际标准（ISO&#x2F;IEC 16262:2011）。到了2012年底，所有主要浏览器都支持 ECMAScript 5.1版的全部功能。\n2013年3月，ECMAScript 6 草案冻结，不再添加新功能。新的功能设想将被放到 ECMAScript 7。\n2013年12月，ECMAScript 6 草案发布。然后是12个月的讨论期，听取各方反馈。\n2015年6月，ECMAScript 6 正式发布，并且更名为“ECMAScript 2015”。这是因为 TC39 委员会计划，以后每年发布一个 ECMAScript 的版本，下一个版本在2016年发布，称为“ECMAScript 2016”，2017年发布“ECMAScript 2017”，以此类推。\n5. 周边大事记JavaScript 伴随着互联网的发展一起发展。互联网周边技术的快速发展，刺激和推动了 JavaScript 语言的发展。下面，回顾一下 JavaScript 的周边应用发展。\n1996年，样式表标准 CSS 第一版发布。\n1997年，DHTML（Dynamic HTML，动态 HTML）发布，允许动态改变网页内容。这标志着 DOM 模式（Document Object Model，文档对象模型）正式应用。\n1998年，Netscape 公司开源了浏览器，这导致了 Mozilla 项目的诞生。几个月后，美国在线（AOL）宣布并购 Netscape。\n1999年，IE 5部署了 XMLHttpRequest 接口，允许 JavaScript 发出 HTTP 请求，为后来大行其道的 Ajax 应用创造了条件。\n2000年，KDE 项目重写了浏览器引擎 KHTML，为后来的 WebKit 和 Blink 引擎打下基础。这一年的10月23日，KDE 2.0发布，第一次将 KHTML 浏览器包括其中。\n2001年，微软公司时隔5年之后，发布了 IE 浏览器的下一个版本 Internet Explorer 6。这是当时最先进的浏览器，它后来统治了浏览器市场多年。\n2001年，Douglas Crockford 提出了 JSON 格式，用于取代 XML 格式，进行服务器和网页之间的数据交换。JavaScript 可以原生支持这种格式，不需要额外部署代码。\n2002年，Mozilla 项目发布了它的浏览器的第一版，后来起名为 Firefox。\n2003年，苹果公司发布了 Safari 浏览器的第一版。\n2004年，Google 公司发布了 Gmail，促成了互联网应用程序（Web Application）这个概念的诞生。由于 Gmail 是在4月1日发布的，很多人起初以为这只是一个玩笑。\n2004年，Dojo 框架诞生，为不同浏览器提供了同一接口，并为主要功能提供了便利的调用方法。这标志着 JavaScript 编程框架的时代开始来临。\n2004年，WHATWG 组织成立，致力于加速 HTML 语言的标准化进程。\n2005年，苹果公司在 KHTML 引擎基础上，建立了 WebKit 引擎。\n2005年，Ajax 方法（Asynchronous JavaScript and XML）正式诞生，Jesse James Garrett 发明了这个词汇。它开始流行的标志是，2月份发布的 Google Maps 项目大量采用该方法。它几乎成了新一代网站的标准做法，促成了 Web 2.0时代的来临。\n2005年，Apache 基金会发布了 CouchDB 数据库。这是一个基于 JSON 格式的数据库，可以用 JavaScript 函数定义视图和索引。它在本质上有别于传统的关系型数据库，标识着 NoSQL 类型的数据库诞生。\n2006年，jQuery 函数库诞生，作者为John Resig。jQuery 为操作网页 DOM 结构提供了非常强大易用的接口，成为了使用最广泛的函数库，并且让 JavaScript 语言的应用难度大大降低，推动了这种语言的流行。\n2006年，微软公司发布 IE 7，标志重新开始启动浏览器的开发。\n2006年，Google推出 Google Web Toolkit 项目（缩写为 GWT），提供 Java 编译成 JavaScript 的功能，开创了将其他语言转为 JavaScript 的先河。\n2007年，Webkit 引擎在 iPhone 手机中得到部署。它最初基于 KDE 项目，2003年苹果公司首先采用，2005年开源。这标志着 JavaScript 语言开始能在手机中使用了，意味着有可能写出在桌面电脑和手机中都能使用的程序。\n2007年，Douglas Crockford 发表了名为《JavaScript: The good parts》的演讲，次年由 O’Reilly 出版社出版。这标志着软件行业开始严肃对待 JavaScript 语言，对它的语法开始重新认识。\n2008年，V8 编译器诞生。这是 Google 公司为 Chrome 浏览器而开发的，它的特点是让 JavaScript 的运行变得非常快。它提高了 JavaScript 的性能，推动了语法的改进和标准化，改变外界对 JavaScript 的不佳印象。同时，V8 是开源的，任何人想要一种快速的嵌入式脚本语言，都可以采用 V8，这拓展了 JavaScript 的应用领域。\n2009年，Node.js 项目诞生，创始人为 Ryan Dahl，它标志着 JavaScript 可以用于服务器端编程，从此网站的前端和后端可以使用同一种语言开发。并且，Node.js 可以承受很大的并发流量，使得开发某些互联网大规模的实时应用变得容易。\n2009年，Jeremy Ashkenas 发布了 CoffeeScript 的最初版本。CoffeeScript 可以被转换为 JavaScript 运行，但是语法要比 JavaScript 简洁。这开启了其他语言转为 JavaScript 的风潮。\n2009年，PhoneGap 项目诞生，它将 HTML5 和 JavaScript 引入移动设备的应用程序开发，主要针对 iOS 和 Android 平台，使得 JavaScript 可以用于跨平台的应用程序开发。\n2009，Google 发布 Chrome OS，号称是以浏览器为基础发展成的操作系统，允许直接使用 JavaScript 编写应用程序。类似的项目还有 Mozilla 的 Firefox OS。\n2010年，三个重要的项目诞生，分别是 NPM、BackboneJS 和 RequireJS，标志着 JavaScript 进入模块化开发的时代。\n2011年，微软公司发布 Windows 8操作系统，将 JavaScript 作为应用程序的开发语言之一，直接提供系统支持。\n2011年，Google 发布了 Dart 语言，目的是为了结束 JavaScript 语言在浏览器中的垄断，提供更合理、更强大的语法和功能。Chromium浏览器有内置的 Dart 虚拟机，可以运行 Dart 程序，但 Dart 程序也可以被编译成 JavaScript 程序运行。\n2011年，微软工程师Scott Hanselman提出，JavaScript 将是互联网的汇编语言。因为它无所不在，而且正在变得越来越快。其他语言的程序可以被转成 JavaScript 语言，然后在浏览器中运行。\n2012年，单页面应用程序框架（single-page app framework）开始崛起，AngularJS 项目和 Ember 项目都发布了1.0版本。\n2012年，微软发布 TypeScript 语言。该语言被设计成 JavaScript 的超集，这意味着所有 JavaScript 程序，都可以不经修改地在 TypeScript 中运行。同时，TypeScript 添加了很多新的语法特性，主要目的是为了开发大型程序，然后还可以被编译成 JavaScript 运行。\n2012年，Mozilla 基金会提出 asm.js 规格。asm.js 是 JavaScript 的一个子集，所有符合 asm.js 的程序都可以在浏览器中运行，它的特殊之处在于语法有严格限定，可以被快速编译成性能良好的机器码。这样做的目的，是为了给其他语言提供一个编译规范，使其可以被编译成高效的 JavaScript 代码。同时，Mozilla 基金会还发起了 Emscripten 项目，目标就是提供一个跨语言的编译器，能够将 LLVM 的位代码（bitcode）转为 JavaScript 代码，在浏览器中运行。因为大部分 LLVM 位代码都是从 C &#x2F; C++ 语言生成的，这意味着 C &#x2F; C++ 将可以在浏览器中运行。此外，Mozilla 旗下还有 LLJS （将 JavaScript 转为 C 代码）项目和 River Trail （一个用于多核心处理器的 ECMAScript 扩展）项目。目前，可以被编译成 JavaScript 的语言列表，共有将近40种语言。\n2013年，Mozilla 基金会发布手机操作系统 Firefox OS，该操作系统的整个用户界面都使用 JavaScript。\n2013年，ECMA 正式推出 JSON 的国际标准，这意味着 JSON 格式已经变得与 XML 格式一样重要和正式了。\n2013年5月，Facebook 发布 UI 框架库 React，引入了新的 JSX 语法，使得 UI 层可以用组件开发，同时引入了网页应用是状态机的概念。\n2014年，微软推出 JavaScript 的 Windows 库 WinJS，标志微软公司全面支持 JavaScript 与 Windows 操作系统的融合。\n2014年11月，由于对 Joyent 公司垄断 Node 项目、以及该项目进展缓慢的不满，一部分核心开发者离开了 Node.js，创造了 io.js 项目，这是一个更开放、更新更频繁的 Node.js 版本，很短时间内就发布到了2.0版。三个月后，Joyent 公司宣布放弃对 Node 项目的控制，将其转交给新成立的开放性质的 Node 基金会。随后，io.js 项目宣布回归 Node，两个版本将合并。\n2015年3月，Facebook 公司发布了 React Native 项目，将 React 框架移植到了手机端，可以用来开发手机 App。它会将 JavaScript 代码转为 iOS 平台的 Objective-C 代码，或者 Android 平台的 Java 代码，从而为 JavaScript 语言开发高性能的原生 App 打开了一条道路。\n2015年4月，Angular 框架宣布，2.0 版将基于微软公司的TypeScript语言开发，这等于为 JavaScript 语言引入了强类型。\n2015年5月，Node 模块管理器 NPM 超越 CPAN，标志着 JavaScript 成为世界上软件模块最多的语言。\n2015年5月，Google 公司的 Polymer 框架发布1.0版。该项目的目标是生产环境可以使用 WebComponent 组件，如果能够达到目标，Web 开发将进入一个全新的以组件为开发基础的阶段。\n2015年6月，ECMA 标准化组织正式批准了 ECMAScript 6 语言标准，定名为《ECMAScript 2015 标准》。JavaScript 语言正式进入了下一个阶段，成为一种企业级的、开发大规模应用的语言。这个标准从提出到批准，历时10年，而 JavaScript 语言从诞生至今也已经20年了。\n2015年6月，Mozilla 在 asm.js 的基础上发布 WebAssembly 项目。这是一种 JavaScript 引擎的中间码格式，全部都是二进制，类似于 Java 的字节码，有利于移动设备加载 JavaScript 脚本，执行速度提高了 20+ 倍。这意味着将来的软件，会发布 JavaScript 二进制包。\n2016年6月，《ECMAScript 2016 标准》发布。与前一年发布的版本相比，它只增加了两个较小的特性。\n2017年6月，《ECMAScript 2017 标准》发布，正式引入了 async 函数，使得异步操作的写法出现了根本的变化。\n2017年11月，所有主流浏览器全部支持 WebAssembly，这意味着任何语言都可以编译成 JavaScript，在浏览器运行。\n6. 参考链接\nAxel Rauschmayer, The Past, Present, and Future of JavaScript\nJohn Dalziel, The race for speed part 4: The future for JavaScript\nAxel Rauschmayer, Basic JavaScript for the impatient programmer\nbalena io, Happy 18th Birthday JavaScript! A look at an unlikely past and bright future\n\n\n未完待续\n","tags":["教程","JavaScript"]},{"title":"从零开始学JavaScript（004 JavaScript 的数据类型概述）","url":"/2023/08/18/js004/","content":"JavaScript 语言的每一个值，都属于某一种数据类型。JavaScript 的数据类型，共有六种。（ES6 又新增了 Symbol 和 BigInt 数据类型，本文暂不涉及。）\n\n简介\n数值（number）：整数和小数（比如1和3.14）。\n字符串（string）：文本（比如Hello World）。\n布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假）。\nundefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值。\nnull：表示空值，即此处的值为空。\n对象（object）：各种值组成的集合。\n\n通常，数值、字符串、布尔值这三种类型，合称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。对象则称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于undefined和null，一般将它们看成两个特殊值。\n对象是最复杂的数据类型，又可以分成三个子类型。\n\n狭义的对象（object）\n数组（array）\n函数（function）\n\n狭义的对象和数组是两种不同的数据组合方式，除非特别声明，本教程的“对象”都特指狭义的对象。函数其实是处理数据的方法，JavaScript 把它当成一种数据类型，可以赋值给变量，这为编程带来了很大的灵活性，也为 JavaScript 的“函数式编程”奠定了基础。\ntypeof 运算符JavaScript 有三种方法，可以确定一个值到底是什么类型。\n\ntypeof运算符\ninstanceof运算符\nObject.prototype.toString方法\n\ninstanceof运算符和Object.prototype.toString方法，将在后文介绍。这里介绍typeof运算符。\ntypeof运算符可以返回一个值的数据类型。\n数值、字符串、布尔值分别返回number、string、boolean。\ntypeof 123 // &quot;number&quot;typeof &#x27;123&#x27; // &quot;string&quot;typeof false // &quot;boolean&quot;\n\n函数返回function。\nfunction f() &#123;&#125;typeof f// &quot;function&quot;\n\nundefined返回undefined。\ntypeof undefined// &quot;undefined&quot;\n\n利用这一点，typeof可以用来检查一个没有声明的变量，而不报错。\nv// ReferenceError: v is not definedtypeof v// &quot;undefined&quot;\n\n上面代码中，变量v没有用var命令声明，直接使用就会报错。但是，放在typeof后面，就不报错了，而是返回undefined。\n实际编程中，这个特点通常用在判断语句。\n// 错误的写法if (v) &#123;  // ...&#125;// ReferenceError: v is not defined// 正确的写法if (typeof v === &quot;undefined&quot;) &#123;  // ...&#125;\n\n对象返回object。\ntypeof window // &quot;object&quot;typeof &#123;&#125; // &quot;object&quot;typeof [] // &quot;object&quot;\n\n上面代码中，空数组（[]）的类型也是object，这表示在 JavaScript 内部，数组本质上只是一种特殊的对象。这里顺便提一下，instanceof运算符可以区分数组和对象。instanceof运算符的详细解释，请见《面向对象编程》一章。\nvar o = &#123;&#125;;var a = [];o instanceof Array // falsea instanceof Array // true\n\nnull返回object。\ntypeof null // &quot;object&quot;\n\nnull的类型是object，这是由于历史原因造成的。1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑null，只把它当作object的一种特殊值。后来null独立出来，作为一种单独的数据类型，为了兼容以前的代码，typeof null返回object就没法改变了。\n参考链接\nAxel Rauschmayer, Improving the JavaScript typeof operator\n\n\n未完待续\n","tags":["教程","JavaScript"]},{"title":"从零开始学JavaScript（003 JavaScript 的基本语法）","url":"/2023/08/17/js003/","content":"JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。\n\n1. 语句语句（statement）是为了完成某种任务而进行的操作，比如下面就是一行赋值语句。\nvar a = 1 + 3;\n这条语句先用var命令，声明了变量a，然后将1 + 3的运算结果赋值给变量a。\n1 + 3叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。凡是 JavaScript 语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。\n语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。\nvar a = 1 + 3 ; var b = &#x27;abc&#x27;;\n分号前面可以没有任何内容，JavaScript 引擎将其视为空语句。\n;;;\n上面的代码就表示3个空语句。\n表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。\n1 + 3;&#x27;abc&#x27;;\n上面两行语句只是单纯地产生一个值，并没有任何实际的意义。\n2. 变量2.1 概念变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。\nvar a = 1;\n上面的代码先声明变量a，然后在变量a与数值1之间建立引用关系，称为将数值1“赋值”给变量a。以后，引用变量名a就会得到数值1。最前面的var，是变量声明命令。它表示通知解释引擎，要创建一个变量a。\n注意，JavaScript 的变量名区分大小写，A和a是两个不同的变量。\n变量的声明和赋值，是分开的两个步骤，上面的代码将它们合在了一起，实际的步骤是下面这样。\nvar a;a = 1;\n如果只是声明变量而没有赋值，则该变量的值是undefined。undefined是一个特殊的值，表示“无定义”。\nvar a;a // undefined\n如果变量赋值的时候，忘了写var命令，这条语句也是有效的。\nvar a = 1;// 基本等同a = 1;\n\n但是，不写var的做法，不利于表达意图，而且容易不知不觉地创建全局变量，所以建议总是使用var命令声明变量。\n如果一个变量没有声明就直接使用，JavaScript 会报错，告诉你变量未定义。\nx// ReferenceError: x is not defined\n上面代码直接使用变量x，系统就报错，告诉你变量x没有声明。\n可以在同一条var命令中声明多个变量。\nvar a, b;\nJavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。\nvar a = 1;a = &#x27;hello&#x27;;\n上面代码中，变量a起先被赋值为一个数值，后来又被重新赋值为一个字符串。第二次赋值的时候，因为变量a已经存在，所以不需要使用var命令。\n如果使用var重新声明一个已经存在的变量，是无效的。\nvar x = 1;var x;x // 1\n上面代码中，变量x声明了两次，第二次声明是无效的。\n但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。\nvar x = 1;var x = 2;// 等同于var x = 1;var x;x = 2;\n变量提升JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。\nconsole.log(a);var a = 1;\n\n上面代码首先使用console.log方法，在控制台（console）显示变量a的值。这时变量a还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。\nvar a;console.log(a);a = 1;\n最后的结果是显示undefined，表示变量a已声明，但还未赋值。\n3.标识符标识符（identifier）指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript 语言的标识符对大小写敏感，所以a和A是两个不同的标识符。\n标识符有一套命名规则，不符合规则的就是非法标识符。JavaScript 引擎遇到非法标识符，就会报错。\n简单说，标识符命名规则如下。\n第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（**$）和下划线（_）。第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9**。下面这些都是合法的标识符。\narg0_tmp$elemπ\n\n下面这些则是不合法的标识符。\n1a  // 第一个字符不能是数字23  // 同上***  // 标识符不能包含星号a+b  // 标识符不能包含加号-d  // 标识符不能包含减号或连词线\n中文是合法的标识符，可以用作变量名。\nvar 临时变量 = 1;\n\n\nJavaScript 有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。\n\n4.注释源码中被 JavaScript 引擎忽略的部分就叫做注释，它的作用是对代码进行解释。JavaScript 提供两种注释的写法：一种是单行注释，用//起头；另一种是多行注释，放在/*和*/之间。\n// 这是单行注释/* 这是 多行 注释*/\n此外，由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以&lt;!--和--&gt;也被视为合法的单行注释。\nx = 1; &lt;!-- x = 2;--&gt; x = 3;\n上面代码中，只有x = 1会执行，其他的部分都被注释掉了。需要注意的是，--&gt;只有在行首，才会被当成单行注释，否则会当作正常的运算。\nfunction countdown(n) &#123;  while (n --&gt; 0) console.log(n);&#125;countdown(3)// 2// 1// 0\n上面代码中，n --&gt; 0实际上会当作n-- &gt; 0，因此输出2、1、0。\n5. 区块JavaScript 使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。\n对于var命令来说，JavaScript 的区块不构成单独的作用域（scope）。\n&#123;  var a = 1;&#125;a // 1\n上面代码在区块内部，使用var命令声明并赋值了变量a，然后在区块外部，变量a依然有效，区块对于var命令不构成单独的作用域，与不使用区块的情况没有任何区别。在 JavaScript 语言中，单独使用区块并不常见，区块往往用来构成其他更复杂的语法结构，比如for、if、while、function等。\n6. 条件语句JavaScript 提供if结构和switch结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句。\n6.1 if结构if结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，指的是 JavaScript 的两个特殊值，true表示“真”，false表示“伪”。\nif (布尔值)  语句;// 或者if (布尔值) 语句;\n上面是if结构的基本形式。需要注意的是，“布尔值”往往由一个条件表达式产生的，必须放在圆括号中，表示对表达式求值。如果表达式的求值结果为true，就执行紧跟在后面的语句；如果结果为false，则跳过紧跟在后面的语句。\nif (m === 3)  m = m + 1;\n上面代码表示，只有在m等于3时，才会将其值加上1。\n这种写法要求条件表达式后面只能有一个语句。如果想执行多个语句，必须在if的条件判断之后，加上大括号，表示代码块（多个语句合并成一个语句）。\nif (m === 3) &#123;  m += 1;&#125;\n建议总是在if语句中使用大括号，因为这样方便插入语句。\n注意，if后面的表达式之中，不要混淆赋值表达式（**&#x3D;）、严格相等运算符（&#x3D;&#x3D;&#x3D;）和相等运算符（&#x3D;&#x3D;**）。尤其是赋值表达式不具有比较作用。\nvar x = 1;var y = 2;if (x = y) &#123;  console.log(x);&#125;// &quot;2&quot;\n上面代码的原意是，当x等于y的时候，才执行相关语句。但是，不小心将严格相等运算符写成赋值表达式，结果变成了将y赋值给变量x，再判断变量x的值（等于2）的布尔值（结果为true）。\n这种错误可以正常生成一个布尔值，因而不会报错。为了避免这种情况，有些开发者习惯将常量写在运算符的左边，这样的话，一旦不小心将相等运算符写成赋值运算符，就会报错，因为常量不能被赋值。\nif (x = 2) &#123; // 不报错if (2 = x) &#123; // 报错\n至于为什么优先采用“严格相等运算符”（===），而不是“相等运算符”（==），在后面的学习中笔者会细说。\n6.2 if…else结构if代码块后面，还可以跟一个else代码块，表示不满足条件时，所要执行的代码。\nif (m === 3) &#123;  // 满足条件时，执行的语句&#125; else &#123;  // 不满足条件时，执行的语句&#125;\n上面代码判断变量m是否等于3，如果等于就执行if代码块，否则执行else代码块。\n对同一个变量进行多次判断时，多个if…else语句可以连写在一起。\nif (m === 0) &#123;  // ...&#125; else if (m === 1) &#123;  // ...&#125; else if (m === 2) &#123;  // ...&#125; else &#123;  // ...&#125;\nelse代码块总是与离自己最近的那个if语句配对。\nvar m = 1;var n = 2;if (m !== 1)if (n === 2) console.log(&#x27;hello&#x27;);else console.log(&#x27;world&#x27;);\n上面代码不会有任何输出，else代码块不会得到执行，因为它跟着的是最近的那个if语句，相当于下面这样。\nif (m !== 1) &#123;  if (n === 2) &#123;    console.log(&#x27;hello&#x27;);  &#125; else &#123;    console.log(&#x27;world&#x27;);  &#125;&#125;\n如果想让else代码块跟随最上面的那个if语句，就要改变大括号的位置。\nif (m !== 1) &#123;  if (n === 2) &#123;    console.log(&#x27;hello&#x27;);  &#125;&#125; else &#123;  console.log(&#x27;world&#x27;);&#125;// world\n6.3 switch结构多个if…else连在一起使用的时候，可以转为使用更方便的switch结构。\nswitch (fruit) &#123;  case &quot;banana&quot;:    // ...    break;  case &quot;apple&quot;:    // ...    break;  default:    // ...&#125;\n上面代码根据变量fruit的值，选择执行相应的case。如果所有case都不符合，则执行最后的default部分。需要注意的是，每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构。\nvar x = 1;switch (x) &#123;  case 1:    console.log(&#x27;x 等于1&#x27;);  case 2:    console.log(&#x27;x 等于2&#x27;);  default:    console.log(&#x27;x 等于其他值&#x27;);&#125;// x等于1// x等于2// x等于其他值\n上面代码中，case代码块之中没有break语句，导致不会跳出switch结构，而会一直执行下去。正确的写法是像下面这样。\nswitch (x) &#123;  case 1:    console.log(&#x27;x 等于1&#x27;);    break;  case 2:    console.log(&#x27;x 等于2&#x27;);    break;  default:    console.log(&#x27;x 等于其他值&#x27;);&#125;\nswitch语句部分和case语句部分，都可以使用表达式。\nswitch (1 + 3) &#123;  case 2 + 2:    f();    break;  default:    neverHappens();&#125;\n上面代码的default部分，是永远不会执行到的。\n需要注意的是，switch语句后面的表达式，与case语句后面的表示式比较运行结果时，采用的是严格相等运算符（**&#x3D;&#x3D;&#x3D;），而不是相等运算符（&#x3D;&#x3D;**），这意味着比较时不会发生类型转换。\nvar x = 1;switch (x) &#123;  case true:    console.log(&#x27;x 发生类型转换&#x27;);    break;  default:    console.log(&#x27;x 没有发生类型转换&#x27;);&#125;// x 没有发生类型转换\n上面代码中，由于变量x没有发生类型转换，所以不会执行case true的情况。这表明，switch语句内部采用的是“严格相等运算符”。\n6.4 三元运算符 ? :JavaScript 还有一个三元运算符（即该运算符需要三个运算子）?:，也可以用于逻辑判断。\n(条件) ? 表达式1 : 表达式2\n上面代码中，如果“条件”为true，则返回“表达式1”的值，否则返回“表达式2”的值。\nvar even = (n % 2 === 0) ? true : false;\n\n上面代码中，如果n可以被2整除，则even等于true，否则等于false。它等同于下面的形式。\nvar even;if (n % 2 === 0) &#123;  even = true;&#125; else &#123;  even = false;&#125;\n这个三元运算符可以被视为**if…else…**的简写形式，因此可以用于多种场合。\nvar myVar;console.log(  myVar ?  &#x27;myVar has a value&#x27; :  &#x27;myVar does not have a value&#x27;)// myVar does not have a value\n上面代码利用三元运算符，输出相应的提示。\nvar msg = &#x27;数字&#x27; + n + &#x27;是&#x27; + (n % 2 === 0 ? &#x27;偶数&#x27; : &#x27;奇数&#x27;);\n上面代码利用三元运算符，在字符串之中插入不同的值。\n7. 循环语句循环语句用于重复执行某个操作，它有多种形式。\n7.1 whilewhile语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。\nwhile (条件)  语句;// 或者while (条件) 语句;\nwhile语句的循环条件是一个表达式，必须放在圆括号中。代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号。\nwhile (条件) &#123;  语句;&#125;\n下面是while语句的一个例子。\nvar i = 0;while (i &lt; 100) &#123;  console.log(&#x27;i 当前为：&#x27; + i);  i = i + 1;&#125;\n上面的代码将循环100次，直到i等于100为止。\n下面的例子是一个无限循环，因为循环条件总是为真。\nwhile (true) &#123;  console.log(&#x27;Hello, world&#x27;);&#125;\n7.2 for循环for语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下。\nfor (初始化表达式; 条件; 递增表达式)  语句// 或者for (初始化表达式; 条件; 递增表达式) &#123;  语句&#125;\nfor语句后面的括号里面，有三个表达式。\n\n初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。\n条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。\n递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量。\n下面是一个例子。\n\nvar x = 3;for (var i = 0; i &lt; x; i++) &#123;  console.log(i);&#125;// 0// 1// 2\n上面代码中，初始化表达式是var i &#x3D; 0，即初始化一个变量i；测试表达式是i &lt; x，即只要i小于x，就会执行循环；递增表达式是i++，即每次循环结束后，i增大1。\n所有for循环，都可以改写成while循环。上面的例子改为while循环，代码如下。\nvar x = 3;var i = 0;while (i &lt; x) &#123;  console.log(i);  i++;&#125;\nfor语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。\nfor ( ; ; )&#123;  console.log(&#x27;Hello World&#x27;);&#125;\n上面代码省略了for语句表达式的三个部分，结果就导致了一个无限循环。\n7.3 do…while循环do…while循环与while循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。\ndo  语句while (条件);// 或者do &#123;  语句&#125; while (条件);\n不管条件是否为真，do…while循环至少运行一次，这是这种结构最大的特点。另外，while语句后面的分号注意不要省略。\n下面是一个例子。\nvar x = 3;var i = 0;do &#123;  console.log(i);  i++;&#125; while(i &lt; x);\n\n7.4 break语句和continue语句break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行。\nbreak语句用于跳出代码块或循环。\nvar i = 0;while(i &lt; 100) &#123;  console.log(&#x27;i 当前为：&#x27; + i);  i++;  if (i === 10) break;&#125;\n上面代码只会执行10次循环，一旦i等于10，就会跳出循环。\nfor循环也可以使用break语句跳出循环。\nfor (var i = 0; i &lt; 5; i++) &#123;  console.log(i);  if (i === 3)    break;&#125;// 0// 1// 2// 3\n上面代码执行到i等于3，就会跳出循环。\ncontinue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。\nvar i = 0;while (i &lt; 100)&#123;  i++;  if (i % 2 === 0) continue;  console.log(&#x27;i 当前为：&#x27; + i);&#125;\n上面代码只有在i为奇数时，才会输出i的值。如果i为偶数，则直接进入下一轮循环。\n如果存在多重循环，不带参数的break语句和continue语句都只针对最内层循环。\n7.5标签（label）JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。\nlabel:  语句\n标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。\n标签通常与break语句和continue语句配合使用，跳出特定的循环。\ntop:  for (var i = 0; i &lt; 3; i++)&#123;    for (var j = 0; j &lt; 3; j++)&#123;      if (i === 1 &amp;&amp; j === 1) break top;      console.log(&#x27;i=&#x27; + i + &#x27;, j=&#x27; + j);    &#125;  &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0\n上面代码为一个双重循环区块，break命令后面加上了top标签（注意，top不用加引号），满足条件时，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。\n标签也可以用于跳出代码块。\nfoo: &#123;  console.log(1);  break foo;  console.log(&#x27;本行不会输出&#x27;);&#125;console.log(2);// 1// 2\n上面代码执行到break foo，就会跳出区块。\ncontinue语句也可以与标签配合使用。\ntop:  for (var i = 0; i &lt; 3; i++)&#123;    for (var j = 0; j &lt; 3; j++)&#123;      if (i === 1 &amp;&amp; j === 1) continue top;      console.log(&#x27;i=&#x27; + i + &#x27;, j=&#x27; + j);    &#125;  &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0// i=2, j=0// i=2, j=1// i=2, j=2\n上面代码中，continue命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果continue语句后面不使用标签，则只能进入下一轮的内层循环。\n8.参考链接\nAxel Rauschmayer, Basic JavaScript for the impatient programmer\n\n\n未完待续\n","tags":["教程","JavaScript"]},{"title":"从零开始学JavaScript（005 null, undefined 和布尔值）","url":"/2023/08/18/js005/","content":"null与undefined都可以表示“没有”，含义非常相似。将一个变量赋值为undefined或null，老实说，语法效果几乎没区别。\n\nnull, undefined 和布尔值null 和 undefined概述var a = undefined;// 或者var a = null;\n\n上面代码中，变量a分别被赋值为undefined和null，这两种写法的效果几乎等价。\n在if语句中，它们都会被自动转为false，相等运算符（==）甚至直接报告两者相等。\nif (!undefined) &#123;  console.log(&#x27;undefined is false&#x27;);&#125;// undefined is falseif (!null) &#123;  console.log(&#x27;null is false&#x27;);&#125;// null is falseundefined == null// true\n\n从上面代码可见，两者的行为是何等相似！谷歌公司开发的 JavaScript 语言的替代品 Dart 语言，就明确规定只有null，没有undefined！\n既然含义与用法都差不多，为什么要同时设置两个这样的值，这不是无端增加复杂度，令初学者困扰吗？这与历史原因有关。\n1995年 JavaScript 诞生时，最初像 Java 一样，只设置了null表示”无”。根据 C 语言的传统，null可以自动转为0。\nNumber(null) // 05 + null // 5\n\n上面代码中，null转为数字时，自动变成0。\n但是，JavaScript 的设计者 Brendan Eich，觉得这样做还不够。首先，第一版的 JavaScript 里面，null就像在 Java 里一样，被当成一个对象，Brendan Eich 觉得表示“无”的值最好不是对象。其次，那时的 JavaScript 不包括错误处理机制，Brendan Eich 觉得，如果null自动转为0，很不容易发现错误。\n因此，他又设计了一个undefined。区别是这样的：null是一个表示“空”的对象，转为数值时为0；undefined是一个表示”此处无定义”的原始值，转为数值时为NaN。\nNumber(undefined) // NaN5 + undefined // NaN\n\n用法和含义对于null和undefined，大致可以像下面这样理解。\nnull表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入null，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入null，表示未发生错误。\nundefined表示“未定义”，下面是返回undefined的典型场景。\n// 变量声明了，但没有赋值var i;i // undefined// 调用函数时，应该提供的参数没有提供，该参数等于 undefinedfunction f(x) &#123;  return x;&#125;f() // undefined// 对象没有赋值的属性var  o = new Object();o.p // undefined// 函数没有返回值时，默认返回 undefinedfunction f() &#123;&#125;f() // undefined\n\n布尔值布尔值代表“真”和“假”两个状态。“真”用关键字true表示，“假”用关键字false表示。布尔值只有这两个值。\n下列运算符会返回布尔值：\n\n前置逻辑运算符： ! (Not)\n相等运算符：===，!==，==，!=\n比较运算符：&gt;，&gt;=，&lt;，&lt;=\n\n如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。\n\nundefined\nnull\nfalse\n0\nNaN\n&quot;&quot;或&#39;&#39;（空字符串）\n\n布尔值往往用于程序流程的控制，请看一个例子。\nif (&#x27;&#x27;) &#123;  console.log(&#x27;true&#x27;);&#125;// 没有任何输出\n\n上面代码中，if命令后面的判断条件，预期应该是一个布尔值，所以 JavaScript 自动将空字符串，转为布尔值false，导致程序不会进入代码块，所以没有任何输出。\n注意，空数组（[]）和空对象（&#123;&#125;）对应的布尔值，都是true。\nif ([]) &#123;  console.log(&#x27;true&#x27;);&#125;// trueif (&#123;&#125;) &#123;  console.log(&#x27;true&#x27;);&#125;// true\n\n更多关于数据类型转换的介绍，在后面的学习中会有提及。\n参考链接\nAxel Rauschmayer, Categorizing values in JavaScript\n\n\n未完待续\n","tags":["教程","JavaScript"]},{"title":"从零开始学JavaScript（007 字符串）","url":"/2023/08/18/js007/","content":"简而言之，字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。\n\n字符串概述定义字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。\n&#x27;abc&#x27;&quot;abc&quot;\n\n单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。\n&#x27;key = &quot;value&quot;&#x27;&quot;It&#x27;s a long journey&quot;\n\n上面两个都是合法的字符串。\n如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此。\n&#x27;Did she say \\&#x27;Hello\\&#x27;?&#x27;// &quot;Did she say &#x27;Hello&#x27;?&quot;&quot;Did she say \\&quot;Hello\\&quot;?&quot;// &quot;Did she say &quot;Hello&quot;?&quot;\n\n由于 HTML 语言的属性值使用双引号，所以很多项目约定 JavaScript 语言的字符串只使用单引号，本教程遵守这个约定。当然，只使用双引号也完全可以。重要的是坚持使用一种风格，不要一会使用单引号表示字符串，一会又使用双引号表示。\n字符串默认只能写在一行内，分成多行将会报错。\n&#x27;abc&#x27;// SyntaxError: Unexpected token ILLEGAL\n\n上面代码将一个字符串分成三行，JavaScript 就会报错。\n如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。\nvar longString = &#x27;Long \\long \\long \\string&#x27;;longString// &quot;Long long long string&quot;\n\n上面代码表示，加了反斜杠以后，原来写在一行的字符串，可以分成多行书写。但是，输出的时候还是单行，效果与写在同一行完全一样。注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。\n连接运算符（+）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。\nvar longString = &#x27;Long &#x27;  + &#x27;long &#x27;  + &#x27;long &#x27;  + &#x27;string&#x27;;\n\n如果想输出多行字符串，有一种利用多行注释的变通方法。\n(function () &#123; /*line 1line 2line 3*/&#125;).toString().split(&#x27;\\n&#x27;).slice(1, -1).join(&#x27;\\n&#x27;)// &quot;line 1// line 2// line 3&quot;\n\n上面的例子中，输出的字符串就是多行。\n转义反斜杠（\\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。\n需要用反斜杠转义的特殊字符，主要有下面这些。\n\n\\0 ：null（\\u0000）\n\\b ：后退键（\\u0008）\n\\f ：换页符（\\u000C）\n\\n ：换行符（\\u000A）\n\\r ：回车键（\\u000D）\n\\t ：制表符（\\u0009）\n\\v ：垂直制表符（\\u000B）\n\\&#39; ：单引号（\\u0027）\n\\&quot; ：双引号（\\u0022）\n\\\\ ：反斜杠（\\u005C）\n\n上面这些字符前面加上反斜杠，都表示特殊含义。\nconsole.log(&#x27;1\\n2&#x27;)// 1// 2\n\n上面代码中，\\n表示换行，输出的时候就分成了两行。\n反斜杠还有三种特殊用法。\n（1）\\HHH\n反斜杠后面紧跟三个八进制数（000到377），代表一个字符。HHH对应该字符的 Unicode 码点，比如\\251表示版权符号。显然，这种方法只能输出256种字符。\n（2）\\xHH\n\\x后面紧跟两个十六进制数（00到FF），代表一个字符。HH对应该字符的 Unicode 码点，比如\\xA9表示版权符号。这种方法也只能输出256种字符。\n（3）\\uXXXX\n\\u后面紧跟四个十六进制数（0000到FFFF），代表一个字符。XXXX对应该字符的 Unicode 码点，比如\\u00A9表示版权符号。\n下面是这三种字符特殊写法的例子。\n&#x27;\\251&#x27; // &quot;©&quot;&#x27;\\xA9&#x27; // &quot;©&quot;&#x27;\\u00A9&#x27; // &quot;©&quot;&#x27;\\172&#x27; === &#x27;z&#x27; // true&#x27;\\x7A&#x27; === &#x27;z&#x27; // true&#x27;\\u007A&#x27; === &#x27;z&#x27; // true\n\n如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。\n&#x27;\\a&#x27;// &quot;a&quot;\n\n上面代码中，a是一个正常字符，前面加反斜杠没有特殊含义，反斜杠会被自动省略。\n如果字符串的正常内容之中，需要包含反斜杠，则反斜杠前面需要再加一个反斜杠，用来对自身转义。\n&quot;Prev \\\\ Next&quot;// &quot;Prev \\ Next&quot;\n\n字符串与数组字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。\nvar s = &#x27;hello&#x27;;s[0] // &quot;h&quot;s[1] // &quot;e&quot;s[4] // &quot;o&quot;// 直接对字符串使用方括号运算符&#x27;hello&#x27;[1] // &quot;e&quot;\n\n如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。\n&#x27;abc&#x27;[3] // undefined&#x27;abc&#x27;[-1] // undefined&#x27;abc&#x27;[&#x27;x&#x27;] // undefined\n\n但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。\nvar s = &#x27;hello&#x27;;delete s[0];s // &quot;hello&quot;s[1] = &#x27;a&#x27;;s // &quot;hello&quot;s[5] = &#x27;!&#x27;;s // &quot;hello&quot;\n\n上面代码表示，字符串内部的单个字符无法改变和增删，这些操作会默默地失败。\nlength 属性length属性返回字符串的长度，该属性也是无法改变的。\nvar s = &#x27;hello&#x27;;s.length // 5s.length = 3;s.length // 5s.length = 7;s.length // 5\n\n上面代码表示字符串的length属性无法改变，但是不会报错。\n字符集JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。\nJavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成\\uxxxx的形式，其中xxxx代表该字符的 Unicode 码点。比如，\\u00A9代表版权符号。\nvar s = &#x27;\\u00A9&#x27;;s // &quot;©&quot;\n\n解析代码的时候，JavaScript 会自动识别一个字符是字面形式表示，还是 Unicode 形式表示。输出给用户的时候，所有字符都会转成字面形式。\nvar f\\u006F\\u006F = &#x27;abc&#x27;;foo // &quot;abc&quot;\n\n上面代码中，第一行的变量名foo是 Unicode 形式表示，第二行是字面形式表示。JavaScript 会自动识别。\n我们还需要知道，每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。\n但是，UTF-16 有两种长度：对于码点在U+0000到U+FFFF之间的字符，长度为16位（即2个字节）；对于码点在U+10000到U+10FFFF之间的字符，长度为32位（即4个字节），而且前两个字节在0xD800到0xDBFF之间，后两个字节在0xDC00到0xDFFF之间。举例来说，码点U+1D306对应的字符为𝌆，它写成 UTF-16 就是0xD834 0xDF06。\nJavaScript 对 UTF-16 的支持是不完整的，由于历史原因，只支持两字节的字符，不支持四字节的字符。这是因为 JavaScript 第一版发布的时候，Unicode 的码点只编到U+FFFF，因此两字节足够表示了。后来，Unicode 纳入的字符越来越多，出现了四字节的编码。但是，JavaScript 的标准此时已经定型了，统一将字符长度限制在两字节，导致无法识别四字节的字符。上一节的那个四字节字符𝌆，浏览器会正确识别这是一个字符，但是 JavaScript 无法识别，会认为这是两个字符。\n&#x27;𝌆&#x27;.length // 2\n\n上面代码中，JavaScript 认为𝌆的长度为2，而不是1。\n总结一下，对于码点在U+10000到U+10FFFF之间的字符，JavaScript 总是认为它们是两个字符（length属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是不正确的。\nBase64 转码有时，文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。\n所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。\nJavaScript 原生提供两个 Base64 相关的方法。\n\nbtoa()：任意值转为 Base64 编码\natob()：Base64 编码转为原来的值\n\nvar string = &#x27;Hello World!&#x27;;btoa(string) // &quot;SGVsbG8gV29ybGQh&quot;atob(&#x27;SGVsbG8gV29ybGQh&#x27;) // &quot;Hello World!&quot;\n\n注意，这两个方法不适合非 ASCII 码的字符，会报错。\nbtoa(&#x27;你好&#x27;) // 报错\n\n要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。\nfunction b64Encode(str) &#123;  return btoa(encodeURIComponent(str));&#125;function b64Decode(str) &#123;  return decodeURIComponent(atob(str));&#125;b64Encode(&#x27;你好&#x27;) // &quot;JUU0JUJEJUEwJUU1JUE1JUJE&quot;b64Decode(&#x27;JUU0JUJEJUEwJUU1JUE1JUJE&#x27;) // &quot;你好&quot;\n\n参考链接\nMathias Bynens, JavaScript’s internal character encoding: UCS-2 or UTF-16?\nMathias Bynens, JavaScript has a Unicode problem\nMozilla Developer Network, Window.btoa\n\n\n未完待续\n","tags":["教程","JavaScript"]},{"title":"从零开始学JavaScript（006 数值，树脂666）","url":"/2023/08/18/js006/","content":"JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。\n\n数值概述整数和浮点数JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。（什么梅开二度）\n1 === 1.0 // true\n\n这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算，参见《运算符》一章的“位运算”部分。\n由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。\n0.1 + 0.2 === 0.3// false0.3 / 0.1// 2.9999999999999996(0.3 - 0.2) === (0.2 - 0.1)// false\n\n数值精度根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。\n\n第1位：符号位，0表示正数，1表示负数\n第2位到第12位（共11位）：指数部分\n第13位到第64位（共52位）：小数部分（即有效数字）\n\n符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。\n指数部分一共有11个二进制位，因此大小范围就是0到2047。IEEE 754 规定，如果指数部分的值在0到2047之间（不含两个端点），那么有效数字的第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字这时总是1.xx...xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript 提供的有效数字最长为53个二进制位。\n(-1)^符号位 * 1.xx...xx * 2^指数部分\n\n上面公式是正常情况下（指数部分在0到2047之间），一个数在 JavaScript 内部实际的表示形式。\n精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-253到253，都可以精确表示。\nMath.pow(2, 53)// 9007199254740992Math.pow(2, 53) + 1// 9007199254740992Math.pow(2, 53) + 2// 9007199254740994Math.pow(2, 53) + 3// 9007199254740996Math.pow(2, 53) + 4// 9007199254740996\n\n上面代码中，大于2的53次方以后，整数运算的结果开始出现错误。所以，大于2的53次方的数值，都无法保持精度。由于2的53次方是一个16位的十进制数值，所以简单的法则就是，JavaScript 对15位的十进制数都可以精确处理。\nMath.pow(2, 53)// 9007199254740992// 多出的三个有效数字，将无法保存9007199254740992111// 9007199254740992000\n\n上面示例表明，大于2的53次方以后，多出来的有效数字（最后三位的111）都会无法保存，变成0。\n数值范围根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为21024到2-1023（开区间），超出这个范围的数无法表示。\n如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity。\nMath.pow(2, 1024) // Infinity\n\n如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。\nMath.pow(2, -1075) // 0\n\n下面是一个实际的例子。\nvar x = 0.5;for(var i = 0; i &lt; 25; i++) &#123;  x = x * x;&#125;x // 0\n\n上面代码中，对0.5连续做25次平方，由于最后结果太接近0，超出了可表示的范围，JavaScript 就直接将其转为0。\nJavaScript 提供Number对象的MAX_VALUE和MIN_VALUE属性，返回可以表示的具体的最大值和最小值。\nNumber.MAX_VALUE // 1.7976931348623157e+308Number.MIN_VALUE // 5e-324\n\n数值的表示法JavaScript 的数值有多种表示方法，可以用字面形式直接表示，比如35（十进制）和0xFF（十六进制）。\n数值也可以采用科学计数法表示，下面是几个科学计数法的例子。\n123e3 // 123000123e-3 // 0.123-3.1E+12.1e-23\n\n科学计数法允许字母e或E的后面，跟着一个整数，表示这个数值的指数部分。\n以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。\n（1）小数点前的数字多于21位。\n1234567890123456789012// 1.2345678901234568e+21123456789012345678901// 123456789012345680000\n\n（2）小数点后的零多于5个。\n// 小数点后紧跟5个以上的零，// 就自动转为科学计数法0.0000003 // 3e-7// 否则，就保持原来的字面形式0.000003 // 0.000003\n\n数值的进制使用字面量（literal）直接表示一个数值时，JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。\n\n十进制：没有前导0的数值。\n八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。\n十六进制：有前缀0x或0X的数值。\n二进制：有前缀0b或0B的数值。\n\n默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。下面是一些例子。\n0xff // 2550o377 // 2550b11 // 3\n\n如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。\n0xzz // 报错0o88 // 报错0b22 // 报错\n\n上面代码中，十六进制出现了字母z、八进制出现数字8、二进制出现数字2，因此报错。\n通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字8和9，则该数值被视为十进制。\n0888 // 8880777 // 511\n\n前导0表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。\n特殊数值JavaScript 提供了几个特殊的数值。\n正零和负零前面说过，JavaScript 的64位浮点数之中，有一个二进制位是符号位。这意味着，任何一个数都有一个对应的负值，就连0也不例外。\nJavaScript 内部实际上存在2个0：一个是+0，一个是-0，区别就是64位浮点数表示法的符号位不同。它们是等价的。\n-0 === +0 // true0 === -0 // true0 === +0 // true\n\n几乎所有场合，正零和负零都会被当作正常的0。\n+0 // 0-0 // 0(-0).toString() // &#x27;0&#x27;(+0).toString() // &#x27;0&#x27;\n\n唯一有区别的场合是，+0或-0当作分母，返回的值是不相等的。\n(1 / +0) === (1 / -0) // false\n\n上面的代码之所以出现这样结果，是因为除以正零得到+Infinity，除以负零得到-Infinity，这两者是不相等的（关于Infinity详见下文）。\nNaN（1）含义\nNaN是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。\n5 - &#x27;x&#x27; // NaN\n\n上面代码运行时，会自动将字符串x转为数值，但是由于x不是数值，所以最后得到结果为NaN，表示它是“非数字”（NaN）。\n另外，一些数学函数的运算结果会出现NaN。\nMath.acos(2) // NaNMath.log(-1) // NaNMath.sqrt(-1) // NaN\n\n0除以0也会得到NaN。\n0 / 0 // NaN\n\n需要注意的是，NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。\ntypeof NaN // &#x27;number&#x27;\n\n（2）运算规则\nNaN不等于任何值，包括它本身。\nNaN === NaN // false\n\n数组的indexOf方法内部使用的是严格相等运算符，所以该方法对NaN不成立。\n[NaN].indexOf(NaN) // -1\n\nNaN在布尔运算时被当作false。\nBoolean(NaN) // false\n\nNaN与任何数（包括它自己）的运算，得到的都是NaN。\nNaN + 32 // NaNNaN - 32 // NaNNaN * 32 // NaNNaN / 32 // NaN\n\nInfinity（1）含义\nInfinity表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到Infinity。\n// 场景一Math.pow(2, 1024)// Infinity// 场景二0 / 0 // NaN1 / 0 // Infinity\n\n上面代码中，第一个场景是一个表达式的计算结果太大，超出了能够表示的范围，因此返回Infinity。第二个场景是0除以0会得到NaN，而非0数值除以0，会返回Infinity。\nInfinity有正负之分，Infinity表示正的无穷，-Infinity表示负的无穷。\nInfinity === -Infinity // false1 / -0 // -Infinity-1 / -0 // Infinity\n\n上面代码中，非零正数除以-0，会得到-Infinity，负数除以-0，会得到Infinity。\n由于数值正向溢出（overflow）、负向溢出（underflow）和被0除，JavaScript 都不报错，所以单纯的数学运算几乎没有可能抛出错误。\nInfinity大于一切数值（除了NaN），-Infinity小于一切数值（除了NaN）。\nInfinity &gt; 1000 // true-Infinity &lt; -1000 // true\n\nInfinity与NaN比较，总是返回false。\nInfinity &gt; NaN // false-Infinity &gt; NaN // falseInfinity &lt; NaN // false-Infinity &lt; NaN // false\n\n（2）运算规则\nInfinity的四则运算，符合无穷的数学计算规则。\n5 * Infinity // Infinity5 - Infinity // -InfinityInfinity / 5 // Infinity5 / Infinity // 0\n\n0乘以Infinity，返回NaN；0除以Infinity，返回0；Infinity除以0，返回Infinity。\n0 * Infinity // NaN0 / Infinity // 0Infinity / 0 // Infinity\n\nInfinity加上或乘以Infinity，返回的还是Infinity。\nInfinity + Infinity // InfinityInfinity * Infinity // Infinity\n\nInfinity减去或除以Infinity，得到NaN。\nInfinity - Infinity // NaNInfinity / Infinity // NaN\n\nInfinity与null计算时，null会转成0，等同于与0的计算。\nnull * Infinity // NaNnull / Infinity // 0Infinity / null // Infinity\n\nInfinity与undefined计算，返回的都是NaN。\nundefined + Infinity // NaNundefined - Infinity // NaNundefined * Infinity // NaNundefined / Infinity // NaNInfinity / undefined // NaN\n\n与数值相关的全局方法parseInt()（1）基本用法\nparseInt方法用于将字符串转为整数。\nparseInt(&#x27;123&#x27;) // 123\n\n如果字符串头部有空格，空格会被自动去除。\nparseInt(&#x27;   81&#x27;) // 81\n\n如果parseInt的参数不是字符串，则会先转为字符串再转换。\nparseInt(1.23) // 1// 等同于parseInt(&#x27;1.23&#x27;) // 1\n\n字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。\nparseInt(&#x27;8a&#x27;) // 8parseInt(&#x27;12**&#x27;) // 12parseInt(&#x27;12.34&#x27;) // 12parseInt(&#x27;15e2&#x27;) // 15parseInt(&#x27;15px&#x27;) // 15\n\n上面代码中，parseInt的参数都是字符串，结果只返回字符串头部可以转为数字的部分。\n如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。\nparseInt(&#x27;abc&#x27;) // NaNparseInt(&#x27;.3&#x27;) // NaNparseInt(&#x27;&#x27;) // NaNparseInt(&#x27;+&#x27;) // NaNparseInt(&#x27;+1&#x27;) // 1\n\n所以，parseInt的返回值只有两种可能，要么是一个十进制整数，要么是NaN。\n如果字符串以0x或0X开头，parseInt会将其按照十六进制数解析。\nparseInt(&#x27;0x10&#x27;) // 16\n\n如果字符串以0开头，将其按照10进制解析。\nparseInt(&#x27;011&#x27;) // 11\n\n对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。\nparseInt(1000000000000000000000.5) // 1// 等同于parseInt(&#x27;1e+21&#x27;) // 1parseInt(0.0000008) // 8// 等同于parseInt(&#x27;8e-7&#x27;) // 8\n\n（2）进制转换\nparseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，parseInt的第二个参数为10，即默认是十进制转十进制。\nparseInt(&#x27;1000&#x27;) // 1000// 等同于parseInt(&#x27;1000&#x27;, 10) // 1000\n\n下面是转换指定进制的数的例子。\nparseInt(&#x27;1000&#x27;, 2) // 8parseInt(&#x27;1000&#x27;, 6) // 216parseInt(&#x27;1000&#x27;, 8) // 512\n\n上面代码中，二进制、六进制、八进制的1000，分别等于十进制的8、216和512。这意味着，可以用parseInt方法进行进制的转换。\n如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回NaN。如果第二个参数是0、undefined和null，则直接忽略。\nparseInt(&#x27;10&#x27;, 37) // NaNparseInt(&#x27;10&#x27;, 1) // NaNparseInt(&#x27;10&#x27;, 0) // 10parseInt(&#x27;10&#x27;, null) // 10parseInt(&#x27;10&#x27;, undefined) // 10\n\n如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回NaN。\nparseInt(&#x27;1546&#x27;, 2) // 1parseInt(&#x27;546&#x27;, 2) // NaN\n\n上面代码中，对于二进制来说，1是有意义的字符，5、4、6都是无意义的字符，所以第一行返回1，第二行返回NaN。\n前面说过，如果parseInt的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。\nparseInt(0x11, 36) // 43parseInt(0x11, 2) // 1// 等同于parseInt(String(0x11), 36)parseInt(String(0x11), 2)// 等同于parseInt(&#x27;17&#x27;, 36)parseInt(&#x27;17&#x27;, 2)\n\n上面代码中，十六进制的0x11会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串17，最后返回结果43和1。\n这种处理方式，对于八进制的前缀0，尤其需要注意。\nparseInt(011, 2) // NaN// 等同于parseInt(String(011), 2)// 等同于parseInt(String(9), 2)\n\n上面代码中，第一行的011会被先转为字符串9，因为9不是二进制的有效字符，所以返回NaN。如果直接计算parseInt(&#39;011&#39;, 2)，011则是会被当作二进制处理，返回3。\nJavaScript 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个0。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。\nparseFloat()parseFloat方法用于将一个字符串转为浮点数。\nparseFloat(&#x27;3.14&#x27;) // 3.14\n\n如果字符串符合科学计数法，则会进行相应的转换。\nparseFloat(&#x27;314e-2&#x27;) // 3.14parseFloat(&#x27;0.0314E+2&#x27;) // 3.14\n\n如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。\nparseFloat(&#x27;3.14more non-digit characters&#x27;) // 3.14\n\nparseFloat方法会自动过滤字符串前导的空格。\nparseFloat(&#x27;\\t\\v\\r12.34\\n &#x27;) // 12.34\n\n如果参数不是字符串，则会先转为字符串再转换。\nparseFloat([1.23]) // 1.23// 等同于parseFloat(String([1.23])) // 1.23\n\n如果字符串的第一个字符不能转化为浮点数，则返回NaN。\nparseFloat([]) // NaNparseFloat(&#x27;FF2&#x27;) // NaNparseFloat(&#x27;&#x27;) // NaN\n\n上面代码中，尤其值得注意，parseFloat会将空字符串转为NaN。\n这些特点使得parseFloat的转换结果不同于Number函数。\nparseFloat(true)  // NaNNumber(true) // 1parseFloat(null) // NaNNumber(null) // 0parseFloat(&#x27;&#x27;) // NaNNumber(&#x27;&#x27;) // 0parseFloat(&#x27;123.45#&#x27;) // 123.45Number(&#x27;123.45#&#x27;) // NaN\n\nisNaN()isNaN方法可以用来判断一个值是否为NaN。\nisNaN(NaN) // trueisNaN(123) // false\n\n但是，isNaN只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成NaN，所以最后返回true，这一点要特别引起注意。也就是说，isNaN为true的值，有可能不是NaN，而是一个字符串。\nisNaN(&#x27;Hello&#x27;) // true// 相当于isNaN(Number(&#x27;Hello&#x27;)) // true\n\n出于同样的原因，对于对象和数组，isNaN也返回true。\nisNaN(&#123;&#125;) // true// 等同于isNaN(Number(&#123;&#125;)) // trueisNaN([&#x27;xzy&#x27;]) // true// 等同于isNaN(Number([&#x27;xzy&#x27;])) // true\n\n但是，对于空数组和只有一个数值成员的数组，isNaN返回false。\nisNaN([]) // falseisNaN([123]) // falseisNaN([&#x27;123&#x27;]) // false\n\n上面代码之所以返回false，原因是这些数组能被Number函数转成数值，请参见《数据类型转换》一章。\n因此，使用isNaN之前，最好判断一下数据类型。\nfunction myIsNaN(value) &#123;  return typeof value === &#x27;number&#x27; &amp;&amp; isNaN(value);&#125;\n\n判断NaN更可靠的方法是，利用NaN为唯一不等于自身的值的这个特点，进行判断。\nfunction myIsNaN(value) &#123;  return value !== value;&#125;\n\nisFinite()isFinite方法返回一个布尔值，表示某个值是否为正常的数值。\nisFinite(Infinity) // falseisFinite(-Infinity) // falseisFinite(NaN) // falseisFinite(undefined) // falseisFinite(null) // trueisFinite(-1) // true\n\n除了Infinity、-Infinity、NaN和undefined这几个值会返回false，isFinite对于其他的数值都会返回true。\n参考链接\nDr. Axel Rauschmayer, How numbers are encoded in JavaScript\nHumphry, JavaScript 中 Number 的一些表示上&#x2F;下限\n\n","tags":["教程","JavaScript"]},{"title":"从零开始学JavaScript（008 对象）","url":"/2023/08/19/js008/","content":"对象（object）是 JavaScript 语言的核心概念，也是最重要的数据类型。\n\n对象概述生成方法什么是对象？简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。\nvar obj = &#123;  foo: &#x27;Hello&#x27;,  bar: &#x27;World&#x27;&#125;;\n\n上面代码中，大括号就定义了一个对象，它被赋值给变量obj，所以变量obj就指向一个对象。该对象内部包含两个键值对（又称为两个“成员”），第一个键值对是foo: &#39;Hello&#39;，其中foo是“键名”（成员的名称），字符串Hello是“键值”（成员的值）。键名与键值之间用冒号分隔。第二个键值对是bar: &#39;World&#39;，bar是键名，World是键值。两个键值对之间用逗号分隔。\n键名对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。上面的代码也可以写成下面这样。\nvar obj = &#123;  &#x27;foo&#x27;: &#x27;Hello&#x27;,  &#x27;bar&#x27;: &#x27;World&#x27;&#125;;\n\n如果键名是数值，会被自动转为字符串。\nvar obj = &#123;  1: &#x27;a&#x27;,  3.2: &#x27;b&#x27;,  1e2: true,  1e-2: true,  .234: true,  0xFF: true&#125;;obj// Object &#123;//   1: &quot;a&quot;,//   3.2: &quot;b&quot;,//   100: true,//   0.01: true,//   0.234: true,//   255: true// &#125;obj[&#x27;100&#x27;] // true\n\n上面代码中，对象obj的所有键名虽然看上去像数值，实际上都被自动转成了字符串。\n如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。\n// 报错var obj = &#123;  1p: &#x27;Hello World&#x27;&#125;;// 不报错var obj = &#123;  &#x27;1p&#x27;: &#x27;Hello World&#x27;,  &#x27;h w&#x27;: &#x27;Hello World&#x27;,  &#x27;p+q&#x27;: &#x27;Hello World&#x27;&#125;;\n\n上面对象的三个键名，都不符合标识名的条件，所以必须加上引号。\n对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。\nvar obj = &#123;  p: function (x) &#123;    return 2 * x;  &#125;&#125;;obj.p(1) // 2\n\n上面代码中，对象obj的属性p，就指向一个函数。\n如果属性的值还是一个对象，就形成了链式引用。\nvar o1 = &#123;&#125;;var o2 = &#123; bar: &#x27;hello&#x27; &#125;;o1.foo = o2;o1.foo.bar // &quot;hello&quot;\n\n上面代码中，对象o1的属性foo指向对象o2，就可以链式引用o2的属性。\n对象的属性之间用逗号分隔，最后一个属性后面可以加逗号（trailing comma），也可以不加。\nvar obj = &#123;  p: 123,  m: function () &#123; ... &#125;,&#125;\n\n上面的代码中，m属性后面的那个逗号，有没有都可以。\n属性可以动态创建，不必在对象声明时就指定。\nvar obj = &#123;&#125;;obj.foo = 123;obj.foo // 123\n\n上面代码中，直接对obj对象的foo属性赋值，结果就在运行时创建了foo属性。\n对象的引用如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。\nvar o1 = &#123;&#125;;var o2 = o1;o1.a = 1;o2.a // 1o2.b = 2;o1.b // 2\n\n上面代码中，o1和o2指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性。\n此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。\nvar o1 = &#123;&#125;;var o2 = o1;o1 = 1;o2 // &#123;&#125;\n\n上面代码中，o1和o2指向同一个对象，然后o1的值变为1，这时不会对o2产生影响，o2还是指向原来的那个对象。\n但是，这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝。\nvar x = 1;var y = x;x = 2;y // 1\n\n上面的代码中，当x的值发生变化后，y的值并不变，这就表示y和x并不是指向同一个内存地址。\n表达式还是语句？对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？\n&#123; foo: 123 &#125;\n\nJavaScript 引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含foo属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签foo，指向表达式123。\n为了避免这种歧义，JavaScript 引擎的做法是，如果遇到这种情况，无法确定是对象还是代码块，一律解释为代码块。\n&#123; console.log(123) &#125; // 123\n\n上面的语句是一个代码块，而且只有解释为代码块，才能执行。\n如果要解释为对象，最好在大括号前加上圆括号。因为圆括号的里面，只能是表达式，所以确保大括号只能解释为对象。\n(&#123; foo: 123 &#125;) // 正确(&#123; console.log(123) &#125;) // 报错\n\n这种差异在eval语句（作用是对字符串求值）中反映得最明显。\neval(&#x27;&#123;foo: 123&#125;&#x27;) // 123eval(&#x27;(&#123;foo: 123&#125;)&#x27;) // &#123;foo: 123&#125;\n\n上面代码中，如果没有圆括号，eval将其理解为一个代码块；加上圆括号以后，就理解成一个对象。\n属性的操作属性的读取读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。\nvar obj = &#123;  p: &#x27;Hello World&#x27;&#125;;obj.p // &quot;Hello World&quot;obj[&#x27;p&#x27;] // &quot;Hello World&quot;\n\n上面代码分别采用点运算符和方括号运算符，读取属性p。\n请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。\nvar foo = &#x27;bar&#x27;;var obj = &#123;  foo: 1,  bar: 2&#125;;obj.foo  // 1obj[foo]  // 2\n\n上面代码中，引用对象obj的foo属性时，如果使用点运算符，foo就是字符串；如果使用方括号运算符，但是不使用引号，那么foo就是一个变量，指向字符串bar。\n方括号运算符内部还可以使用表达式。\nobj[&#x27;hello&#x27; + &#x27; world&#x27;]obj[3 + 3]\n\n数字键可以不加引号，因为会自动转成字符串。\nvar obj = &#123;  0.7: &#x27;Hello World&#x27;&#125;;obj[&#x27;0.7&#x27;] // &quot;Hello World&quot;obj[0.7] // &quot;Hello World&quot;\n\n上面代码中，对象obj的数字键0.7，加不加引号都可以，因为会被自动转为字符串。\n注意，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。\nvar obj = &#123;  123: &#x27;hello world&#x27;&#125;;obj.123 // 报错obj[123] // &quot;hello world&quot;\n\n上面代码的第一个表达式，对数值键名123使用点运算符，结果报错。第二个表达式使用方括号运算符，结果就是正确的。\n属性的赋值点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。\nvar obj = &#123;&#125;;obj.foo = &#x27;Hello&#x27;;obj[&#x27;bar&#x27;] = &#x27;World&#x27;;\n\n上面代码中，分别使用点运算符和方括号运算符，对属性赋值。\nJavaScript 允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。\nvar obj = &#123; p: 1 &#125;;// 等价于var obj = &#123;&#125;;obj.p = 1;\n\n属性的查看查看一个对象本身的所有属性，可以使用Object.keys方法。\nvar obj = &#123;  key1: 1,  key2: 2&#125;;Object.keys(obj);// [&#x27;key1&#x27;, &#x27;key2&#x27;]\n\n属性的删除：delete 命令delete命令用于删除对象的属性，删除成功后返回true。\nvar obj = &#123; p: 1 &#125;;Object.keys(obj) // [&quot;p&quot;]delete obj.p // trueobj.p // undefinedObject.keys(obj) // []\n\n上面代码中，delete命令删除对象obj的p属性。删除后，再读取p属性就会返回undefined，而且Object.keys方法的返回值也不再包括该属性。\n注意，删除一个不存在的属性，delete不报错，而且返回true。\nvar obj = &#123;&#125;;delete obj.p // true\n\n上面代码中，对象obj并没有p属性，但是delete命令照样返回true。因此，不能根据delete命令的结果，认定某个属性是存在的。\n只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。\nvar obj = Object.defineProperty(&#123;&#125;, &#x27;p&#x27;, &#123;  value: 123,  configurable: false&#125;);obj.p // 123delete obj.p // false\n\n上面代码之中，对象obj的p属性是不能删除的，所以delete命令返回false。\n另外，需要注意的是，delete命令只能删除对象本身的属性，无法删除继承的属性。\nvar obj = &#123;&#125;;delete obj.toString // trueobj.toString // function toString() &#123; [native code] &#125;\n\n上面代码中，toString是对象obj继承的属性，虽然delete命令返回true，但该属性并没有被删除，依然存在。这个例子还说明，即使delete返回true，该属性依然可能读取到值。\n属性是否存在：in 运算符in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。它的左边是一个字符串，表示属性名，右边是一个对象。\nvar obj = &#123; p: 1 &#125;;&#x27;p&#x27; in obj // true&#x27;toString&#x27; in obj // true\n\nin运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象obj本身并没有toString属性，但是in运算符会返回true，因为这个属性是继承的。\n这时，可以使用对象的hasOwnProperty方法判断一下，是否为对象自身的属性。\nvar obj = &#123;&#125;;if (&#x27;toString&#x27; in obj) &#123;  console.log(obj.hasOwnProperty(&#x27;toString&#x27;)) // false&#125;\n\n属性的遍历：for…in 循环for...in循环用来遍历一个对象的全部属性。\nvar obj = &#123;a: 1, b: 2, c: 3&#125;;for (var i in obj) &#123;  console.log(&#x27;键名：&#x27;, i);  console.log(&#x27;键值：&#x27;, obj[i]);&#125;// 键名： a// 键值： 1// 键名： b// 键值： 2// 键名： c// 键值： 3\n\nfor...in循环有两个使用注意点。\n\n它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。\n它不仅遍历对象自身的属性，还遍历继承的属性。\n\n举例来说，对象都继承了toString属性，但是for...in循环不会遍历到这个属性。\nvar obj = &#123;&#125;;// toString 属性是存在的obj.toString // toString() &#123; [native code] &#125;for (var p in obj) &#123;  console.log(p);&#125; // 没有任何输出\n\n上面代码中，对象obj继承了toString属性，该属性不会被for...in循环遍历到，因为它默认是“不可遍历”的。\n如果继承的属性是可遍历的，那么就会被for...in循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用for...in的时候，应该结合使用hasOwnProperty方法，在循环内部判断一下，某个属性是否为对象自身的属性。\nvar person = &#123; name: &#x27;老张&#x27; &#125;;for (var key in person) &#123;  if (person.hasOwnProperty(key)) &#123;    console.log(key);  &#125;&#125;// name\n\nwith 语句with语句的格式如下：\nwith (对象) &#123;  语句;&#125;\n\n它的作用是操作同一个对象的多个属性时，提供一些书写的方便。\n// 例一var obj = &#123;  p1: 1,  p2: 2,&#125;;with (obj) &#123;  p1 = 4;  p2 = 5;&#125;// 等同于obj.p1 = 4;obj.p2 = 5;// 例二with (document.links[0])&#123;  console.log(href);  console.log(title);  console.log(style);&#125;// 等同于console.log(document.links[0].href);console.log(document.links[0].title);console.log(document.links[0].style);\n\n注意，如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。\nvar obj = &#123;&#125;;with (obj) &#123;  p1 = 4;  p2 = 5;&#125;obj.p1 // undefinedp1 // 4\n\n上面代码中，对象obj并没有p1属性，对p1赋值等于创造了一个全局变量p1。正确的写法应该是，先定义对象obj的属性p1，然后在with区块内操作它。\n这是因为with区块没有改变作用域，它的内部依然是当前作用域。这造成了with语句的一个很大的弊病，就是绑定对象不明确。\nwith (obj) &#123;  console.log(x);&#125;\n\n单纯从上面的代码块，根本无法判断x到底是全局变量，还是对象obj的一个属性。这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。因此，建议不要使用with语句，可以考虑用一个临时变量代替with。\nwith(obj1.obj2.obj3) &#123;  console.log(p1 + p2);&#125;// 可以写成var temp = obj1.obj2.obj3;console.log(temp.p1 + temp.p2);\n\n参考链接\nDr. Axel Rauschmayer，Object properties in JavaScript\nLakshan Perera, Revisiting JavaScript Objects\nAngus Croll, The Secret Life of JavaScript Primitives\nDr. Axel Rauschmayer, JavaScript’s with statement and why it’s deprecated\n\n\n未完待续\n","tags":["教程","JavaScript"]},{"title":"从零开始学JavaScript（009 函数）","url":"/2023/08/19/js009/","content":"函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数有唯一对应的返回值。\n\n\n函数概述函数的声明JavaScript 有三种声明函数的方法。\n（1）function 命令\nfunction命令声明的代码区块，就是一个函数。function命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。\nfunction print(s) &#123;  console.log(s);&#125;\n\n上面的代码命名了一个print函数，以后使用print()这种形式，就可以调用相应的代码。这叫做函数的声明（Function Declaration）。\n（2）函数表达式\n除了用function命令声明函数，还可以采用变量赋值的写法。\nvar print = function(s) &#123;  console.log(s);&#125;;\n\n这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式。\n采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。\nvar print = function x()&#123;  console.log(typeof x);&#125;;x// ReferenceError: x is not definedprint()// function\n\n上面代码在函数表达式中，加入了函数名x。这个x只在函数体内部可用，指代函数表达式本身，其他地方都不可用。这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。因此，下面的形式声明函数也非常常见。\nvar f = function f() &#123;&#125;;\n\n需要注意的是，函数的表达式需要在语句的结尾加上分号，表示语句结束。而函数的声明在结尾的大括号后面不用加分号。总的来说，这两种声明函数的方式，差别很细微，可以近似认为是等价的。\n（3）Function 构造函数\n第三种声明函数的方式是Function构造函数。\nvar add = new Function(  &#x27;x&#x27;,  &#x27;y&#x27;,  &#x27;return x + y&#x27;);// 等同于function add(x, y) &#123;  return x + y;&#125;\n上面代码中，Function构造函数接受三个参数，除了最后一个参数是add函数的“函数体”，其他参数都是add函数的参数。\n你可以传递任意数量的参数给Function构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。\nvar foo = new Function(  &#x27;return &quot;hello world&quot;;&#x27;);// 等同于function foo() &#123;  return &#x27;hello world&#x27;;&#125;\n\nFunction构造函数可以不使用new命令，返回结果完全一样。\n总的来说，这种声明函数的方式非常不直观，几乎无人使用。\n函数的重复声明如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。\nfunction f() &#123;  console.log(1);&#125;f() // 2function f() &#123;  console.log(2);&#125;f() // 2\n\n上面代码中，后一次的函数声明覆盖了前面一次。而且，由于函数名的提升（参见下文），前一次声明在任何时候都是无效的，这一点要特别注意。\n圆括号运算符，return 语句和递归调用函数时，要使用圆括号运算符。圆括号之中，可以加入函数的参数。\nfunction add(x, y) &#123;  return x + y;&#125;add(1, 1) // 2\n\n上面代码中，函数名后面紧跟一对圆括号，就会调用这个函数。\n函数体内部的return语句，表示返回。JavaScript 引擎遇到return语句，就直接返回return后面的那个表达式的值，后面即使还有语句，也不会得到执行。也就是说，return语句所带的那个表达式，就是函数的返回值。return语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回undefined。\n函数可以调用自身，这就是递归（recursion）。下面就是通过递归，计算斐波那契数列的代码。\nfunction fib(num) &#123;  if (num === 0) return 0;  if (num === 1) return 1;  return fib(num - 2) + fib(num - 1);&#125;fib(6) // 8\n\n上面代码中，fib函数内部又调用了fib，计算得到斐波那契数列的第6个元素是8。\n第一等公民JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处。\n由于函数与其他数据类型地位平等，所以在 JavaScript 语言中又称函数为第一等公民。\nfunction add(x, y) &#123;  return x + y;&#125;// 将函数赋值给一个变量var operator = add;// 将函数作为参数和返回值function a(op)&#123;  return op;&#125;a(add)(1, 1)// 2\n\n函数名的提升JavaScript 引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。\nf();function f() &#123;&#125;\n\n表面上，上面代码好像在声明之前就调用了函数f。但是实际上，由于“变量提升”，函数f被提升到了代码头部，也就是在调用之前已经声明了。但是，如果采用赋值语句定义函数，JavaScript 就会报错。\nf();var f = function ()&#123;&#125;;// TypeError: undefined is not a function\n\n上面的代码等同于下面的形式。\nvar f;f();f = function () &#123;&#125;;\n\n上面代码第二行，调用f的时候，f只是被声明了，还没有被赋值，等于undefined，所以会报错。\n注意，如果像下面例子那样，采用function命令和var赋值语句声明同一个函数，由于存在函数提升，最后会采用var赋值语句的定义。\nvar f = function () &#123;  console.log(&#x27;1&#x27;);&#125;function f() &#123;  console.log(&#x27;2&#x27;);&#125;f() // 1\n\n上面例子中，表面上后面声明的函数f，应该覆盖前面的var赋值语句，但是由于存在函数提升，实际上正好反过来。\n函数的属性和方法name 属性函数的name属性返回函数的名字。\nfunction f1() &#123;&#125;f1.name // &quot;f1&quot;\n\n如果是通过变量赋值定义的函数，那么name属性返回变量名。\nvar f2 = function () &#123;&#125;;f2.name // &quot;f2&quot;\n\n但是，上面这种情况，只有在变量的值是一个匿名函数时才是如此。如果变量的值是一个具名函数，那么name属性返回function关键字之后的那个函数名。\nvar f3 = function myName() &#123;&#125;;f3.name // &#x27;myName&#x27;\n\n上面代码中，f3.name返回函数表达式的名字。注意，真正的函数名还是f3，而myName这个名字只在函数体内部可用。\nname属性的一个用处，就是获取参数函数的名字。\nvar myFunc = function () &#123;&#125;;function test(f) &#123;  console.log(f.name);&#125;test(myFunc) // myFunc\n\n上面代码中，函数test内部通过name属性，就可以知道传入的参数是什么函数。\nlength 属性函数的length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。\nfunction f(a, b) &#123;&#125;f.length // 2\n\n上面代码定义了空函数f，它的length属性就是定义时的参数个数。不管调用时输入了多少个参数，length属性始终等于2。\nlength属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的“方法重载”（overload）。\ntoString()函数的toString()方法返回一个字符串，内容是函数的源码。\nfunction f() &#123;  a();  b();  c();&#125;f.toString()// function f() &#123;//  a();//  b();//  c();// &#125;\n\n上面示例中，函数f的toString()方法返回了f的源码，包含换行符在内。\n对于那些原生的函数，toString()方法返回function ()&#123;[native code]&#125;。\nMath.sqrt.toString()// &quot;function sqrt() &#123; [native code] &#125;&quot;\n\n上面代码中，Math.sqrt()是 JavaScript 引擎提供的原生函数，toString()方法就返回原生代码的提示。\n函数内部的注释也可以返回。\nfunction f() &#123;/*  这是一个  多行注释*/&#125;f.toString()// &quot;function f()&#123;/*//   这是一个//   多行注释// */&#125;&quot;\n\n利用这一点，可以变相实现多行字符串。\nvar multiline = function (fn) &#123;  var arr = fn.toString().split(&#x27;\\n&#x27;);  return arr.slice(1, arr.length - 1).join(&#x27;\\n&#x27;);&#125;;function f() &#123;/*  这是一个  多行注释*/&#125;multiline(f);// &quot; 这是一个//   多行注释&quot;\n\n上面示例中，函数f内部有一个多行注释，toString()方法拿到f的源码后，去掉首尾两行，就得到了一个多行字符串。\n函数作用域定义作用域（scope）指的是变量存在的范围。在 ES5 的规范中，JavaScript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。ES6 又新增了块级作用域，本教程不涉及。\n对于顶层函数来说，函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。\nvar v = 1;function f() &#123;  console.log(v);&#125;f()// 1\n\n上面的代码表明，函数f内部可以读取全局变量v。\n在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）。\nfunction f()&#123;  var v = 1;&#125;v // ReferenceError: v is not defined\n\n上面代码中，变量v在函数内部定义，所以是一个局部变量，函数之外就无法读取。\n函数内部定义的变量，会在该作用域内覆盖同名全局变量。\nvar v = 1;function f()&#123;  var v = 2;  console.log(v);&#125;f() // 2v // 1\n\n上面代码中，变量v同时在函数的外部和内部有定义。结果，在函数内部定义，局部变量v覆盖了全局变量v。\n注意，对于var命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。\nif (true) &#123;  var x = 5;&#125;console.log(x);  // 5\n\n上面代码中，变量x在条件判断区块之中声明，结果就是一个全局变量，可以在区块之外读取。\n函数内部的变量提升与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。\nfunction foo(x) &#123;  if (x &gt; 100) &#123;    var tmp = x - 100;  &#125;&#125;// 等同于function foo(x) &#123;  var tmp;  if (x &gt; 100) &#123;    tmp = x - 100;  &#125;;&#125;\n\n函数本身的作用域函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。\nvar a = 1;var x = function () &#123;  console.log(a);&#125;;function f() &#123;  var a = 2;  x();&#125;f() // 1\n\n上面代码中，函数x是在函数f的外部声明的，所以它的作用域绑定外层，内部变量a不会到函数f体内取值，所以输出1，而不是2。\n总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。\n很容易犯错的一点是，如果函数A调用函数B，却没考虑到函数B不会引用函数A的内部变量。\nvar x = function () &#123;  console.log(a);&#125;;function y(f) &#123;  var a = 2;  f();&#125;y(x)// ReferenceError: a is not defined\n\n上面代码将函数x作为参数，传入函数y。但是，函数x是在函数y体外声明的，作用域绑定外层，因此找不到函数y的内部变量a，导致报错。\n同样的，函数体内部声明的函数，作用域绑定函数体内部。\nfunction foo() &#123;  var x = 1;  function bar() &#123;    console.log(x);  &#125;  return bar;&#125;var x = 2;var f = foo();f() // 1\n\n上面代码中，函数foo内部声明了一个函数bar，bar的作用域绑定foo。当我们在foo外部取出bar执行时，变量x指向的是foo内部的x，而不是foo外部的x。正是这种机制，构成了下文要讲解的“闭包”现象。\n参数概述函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数。\nfunction square(x) &#123;  return x * x;&#125;square(2) // 4square(3) // 9\n\n上式的x就是square函数的参数。每次运行的时候，需要提供这个值，否则得不到结果。\n参数的省略函数参数不是必需的，JavaScript 允许省略参数。\nfunction f(a, b) &#123;  return a;&#125;f(1, 2, 3) // 1f(1) // 1f() // undefinedf.length // 2\n\n上面代码的函数f定义了两个参数，但是运行时无论提供多少个参数（或者不提供参数），JavaScript 都不会报错。省略的参数的值就变为undefined。需要注意的是，函数的length属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。\n但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入undefined。\nfunction f(a, b) &#123;  return a;&#125;f( , 1) // SyntaxError: Unexpected token ,(…)f(undefined, 1) // undefined\n\n上面代码中，如果省略第一个参数，就会报错。\n传递方式函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。\nvar p = 2;function f(p) &#123;  p = 3;&#125;f(p);p // 2\n\n上面代码中，变量p是一个原始类型的值，传入函数f的方式是传值传递。因此，在函数内部，p的值是原始值的拷贝，无论怎么修改，都不会影响到原始值。\n但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。\nvar obj = &#123; p: 1 &#125;;function f(o) &#123;  o.p = 2;&#125;f(obj);obj.p // 2\n\n上面代码中，传入函数f的是参数对象obj的地址。因此，在函数内部修改obj的属性p，会影响到原始值。\n注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。\nvar obj = [1, 2, 3];function f(o) &#123;  o = [2, 3, 4];&#125;f(obj);obj // [1, 2, 3]\n\n上面代码中，在函数f()内部，参数对象obj被整个替换成另一个值。这时不会影响到原始值。这是因为，形式参数（o）的值实际是参数obj的地址，重新对o赋值导致o指向另一个地址，保存在原地址上的值当然不受影响。\n同名参数如果有同名的参数，则取最后出现的那个值。\nfunction f(a, a) &#123;  console.log(a);&#125;f(1, 2) // 2\n\n上面代码中，函数f()有两个参数，且参数名都是a。取值的时候，以后面的a为准，即使后面的a没有值或被省略，也是以其为准。\nfunction f(a, a) &#123;  console.log(a);&#125;f(1) // undefined\n\n调用函数f()的时候，没有提供第二个参数，a的取值就变成了undefined。这时，如果要获得第一个a的值，可以使用arguments对象。\nfunction f(a, a) &#123;  console.log(arguments[0]);&#125;f(1) // 1\n\narguments 对象（1）定义\n由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。\narguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。\nvar f = function (one) &#123;  console.log(arguments[0]);  console.log(arguments[1]);  console.log(arguments[2]);&#125;f(1, 2, 3)// 1// 2// 3\n\n正常模式下，arguments对象可以在运行时修改。\nvar f = function(a, b) &#123;  arguments[0] = 3;  arguments[1] = 2;  return a + b;&#125;f(1, 1) // 5\n\n上面代码中，函数f()调用时传入的参数，在函数内部被修改成3和2。\n严格模式下，arguments对象与函数参数不具有联动关系。也就是说，修改arguments对象不会影响到实际的函数参数。\nvar f = function(a, b) &#123;  &#x27;use strict&#x27;; // 开启严格模式  arguments[0] = 3;  arguments[1] = 2;  return a + b;&#125;f(1, 1) // 2\n\n上面代码中，函数体内是严格模式，这时修改arguments对象，不会影响到真实参数a和b。\n通过arguments对象的length属性，可以判断函数调用时到底带几个参数。\nfunction f() &#123;  return arguments.length;&#125;f(1, 2, 3) // 3f(1) // 1f() // 0\n\n（2）与数组的关系\n需要注意的是，虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。\n如果要让arguments对象使用数组方法，真正的解决方法是将arguments转为真正的数组。下面是两种常用的转换方法：slice方法和逐一填入新数组。\nvar args = Array.prototype.slice.call(arguments);// 或者var args = [];for (var i = 0; i &lt; arguments.length; i++) &#123;  args.push(arguments[i]);&#125;\n\n（3）callee 属性\narguments对象带有一个callee属性，返回它所对应的原函数。\nvar f = function () &#123;  console.log(arguments.callee === f);&#125;f() // true\n\n可以通过arguments.callee，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。\n函数的其他知识点闭包闭包（closure）是 JavaScript 语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。\n理解闭包，首先必须理解变量作用域。前面提到，JavaScript 有两种作用域：全局作用域和函数作用域。函数内部可以直接读取全局变量。\nvar n = 999;function f1() &#123;  console.log(n);&#125;f1() // 999\n\n上面代码中，函数f1可以读取全局变量n。\n但是，正常情况下，函数外部无法读取函数内部声明的变量。\nfunction f1() &#123;  var n = 999;&#125;console.log(n)// Uncaught ReferenceError: n is not defined(\n\n上面代码中，函数f1内部声明的变量n，函数外是无法读取的。\n如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。\nfunction f1() &#123;  var n = 999;  function f2() &#123;　　console.log(n); // 999  &#125;&#125;\n\n上面代码中，函数f2就在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是 JavaScript 语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。\n既然f2可以读取f1的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！\nfunction f1() &#123;  var n = 999;  function f2() &#123;    console.log(n);  &#125;  return f2;&#125;var result = f1();result(); // 999\n\n上面代码中，函数f1的返回值就是函数f2，由于f2可以读取f1的内部变量，所以就可以在外部获得f1的内部变量了。\n闭包就是函数f2，即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。\n闭包的最大用处有两个，一个是可以读取外层函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。\nfunction createIncrementor(start) &#123;  return function () &#123;    return start++;  &#125;;&#125;var inc = createIncrementor(5);inc() // 5inc() // 6inc() // 7\n\n上面代码中，start是函数createIncrementor的内部变量。通过闭包，start的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包inc使得函数createIncrementor的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。\n为什么闭包能够返回外层函数的内部变量？原因是闭包（上例的inc）用到了外层变量（start），导致外层函数（createIncrementor）不能从内存释放。只要闭包没有被垃圾回收机制清除，外层函数提供的运行环境也不会被清除，它的内部变量就始终保存着当前值，供闭包读取。\n闭包的另一个用处，是封装对象的私有属性和私有方法。\nfunction Person(name) &#123;  var _age;  function setAge(n) &#123;    _age = n;  &#125;  function getAge() &#123;    return _age;  &#125;  return &#123;    name: name,    getAge: getAge,    setAge: setAge  &#125;;&#125;var p1 = Person(&#x27;张三&#x27;);p1.setAge(25);p1.getAge() // 25\n\n上面代码中，函数Person的内部变量_age，通过闭包getAge和setAge，变成了返回对象p1的私有变量。\n注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。\n立即调用的函数表达式（IIFE）根据 JavaScript 的语法，圆括号()跟在函数名之后，表示调用该函数。比如，print()就表示调用print函数。\n有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。\nfunction()&#123; /* code */ &#125;();// SyntaxError: Unexpected token (\n\n产生这个错误的原因是，function这个关键字既可以当作语句，也可以当作表达式。\n// 语句function f() &#123;&#125;// 表达式var f = function f() &#123;&#125;\n\n当作表达式时，函数可以定义后直接加圆括号调用。\nvar f = function f()&#123; return 1&#125;();f // 1\n\n上面的代码中，函数定义后直接加圆括号调用，没有报错。原因就是function作为表达式，引擎就把函数定义当作一个值。这种情况下，就不会报错。\n为了避免解析的歧义，JavaScript 规定，如果function关键字出现在行首，一律解释成语句。因此，引擎看到行首是function关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。\n函数定义后立即调用的解决方法，就是不要让function出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。\n(function()&#123; /* code */ &#125;());// 或者(function()&#123; /* code */ &#125;)();\n\n上面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表达式，而不是函数定义语句，所以就避免了错误。这就叫做“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称 IIFE。\n注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个 IIFE，可能就会报错。\n// 报错(function()&#123; /* code */ &#125;())(function()&#123; /* code */ &#125;())\n\n上面代码的两行之间没有分号，JavaScript 会将它们连在一起解释，将第二行解释为第一行的参数。\n推而广之，任何让解释器以表达式来处理函数定义的方法，都能产生同样的效果，比如下面三种写法。\nvar i = function()&#123; return 10; &#125;();true &amp;&amp; function()&#123; /* code */ &#125;();0, function()&#123; /* code */ &#125;();\n\n甚至像下面这样写，也是可以的。\n!function () &#123; /* code */ &#125;();~function () &#123; /* code */ &#125;();-function () &#123; /* code */ &#125;();+function () &#123; /* code */ &#125;();\n\n通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。\n// 写法一var tmp = newData;processData(tmp);storeData(tmp);// 写法二(function () &#123;  var tmp = newData;  processData(tmp);  storeData(tmp);&#125;());\n\n上面代码中，写法二比写法一更好，因为完全避免了污染全局变量。\neval 命令基本用法eval命令接受一个字符串作为参数，并将这个字符串当作语句执行。\neval(&#x27;var a = 1;&#x27;);a // 1\n\n上面代码将字符串当作语句运行，生成了变量a。\n如果参数字符串无法当作语句运行，那么就会报错。\neval(&#x27;3x&#x27;) // Uncaught SyntaxError: Invalid or unexpected token\n\n放在eval中的字符串，应该有独自存在的意义，不能用来与eval以外的命令配合使用。举例来说，下面的代码将会报错。\neval(&#x27;return;&#x27;); // Uncaught SyntaxError: Illegal return statement\n\n上面代码会报错，因为return不能单独使用，必须在函数中使用。\n如果eval的参数不是字符串，那么会原样返回。\neval(123) // 123\n\neval没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。\nvar a = 1;eval(&#x27;a = 2&#x27;);a // 2\n\n上面代码中，eval命令修改了外部变量a的值。由于这个原因，eval有安全风险。\n为了防止这种风险，JavaScript 规定，如果使用严格模式，eval内部声明的变量，不会影响到外部作用域。\n(function f() &#123;  &#x27;use strict&#x27;;  eval(&#x27;var foo = 123&#x27;);  console.log(foo);  // ReferenceError: foo is not defined&#125;)()\n\n上面代码中，函数f内部是严格模式，这时eval内部声明的foo变量，就不会影响到外部。\n不过，即使在严格模式下，eval依然可以读写当前作用域的变量。\n(function f() &#123;  &#x27;use strict&#x27;;  var foo = 1;  eval(&#x27;foo = 2&#x27;);  console.log(foo);  // 2&#125;)()\n\n上面代码中，严格模式下，eval内部还是改写了外部变量，可见安全风险依然存在。\n总之，eval的本质是在当前作用域之中，注入代码。由于安全风险和不利于 JavaScript 引擎优化执行速度，一般不推荐使用。通常情况下，eval最常见的场合是解析 JSON 数据的字符串，不过正确的做法应该是使用原生的JSON.parse方法。\neval 的别名调用前面说过eval不利于引擎优化执行速度。更麻烦的是，还有下面这种情况，引擎在静态代码分析的阶段，根本无法分辨执行的是eval。\nvar m = eval;m(&#x27;var x = 1&#x27;);x // 1\n\n上面代码中，变量m是eval的别名。静态代码分析阶段，引擎分辨不出m(&#39;var x = 1&#39;)执行的是eval命令。\n为了保证eval的别名不影响代码优化，JavaScript 的标准规定，凡是使用别名执行eval，eval内部一律是全局作用域。\nvar a = 1;function f() &#123;  var a = 2;  var e = eval;  e(&#x27;console.log(a)&#x27;);&#125;f() // 1\n\n上面代码中，eval是别名调用，所以即使它是在函数中，它的作用域还是全局作用域，因此输出的a为全局变量。这样的话，引擎就能确认e()不会对当前的函数作用域产生影响，优化的时候就可以把这一行排除掉。\neval的别名调用的形式五花八门，只要不是直接调用，都属于别名调用，因为引擎只能分辨eval()这一种形式是直接调用。\neval.call(null, &#x27;...&#x27;)window.eval(&#x27;...&#x27;)(1, eval)(&#x27;...&#x27;)(eval, eval)(&#x27;...&#x27;)\n\n上面这些形式都是eval的别名调用，作用域都是全局作用域。\n参考链接\nBen Alman, Immediately-Invoked Function Expression (IIFE)\nMark Daggett, Functions Explained\nJuriy Zaytsev, Named function expressions demystified\nMarco Rogers polotek, What is the arguments object?\nJuriy Zaytsev, Global eval. What are the options?\nAxel Rauschmayer, Evaluating JavaScript code via eval() and new Function()\n\n\n未完待续\n","tags":["教程","JavaScript"]},{"title":"从零开始学JavaScript（011 算术运算符）","url":"/2023/08/21/js011/","content":"运算符是处理数据的基本方法，用来从现有的值得到新的值。JavaScript 提供了多种运算符，覆盖了所有主要的运算。\n\n算术运算符概述JavaScript 共提供10个算术运算符，用来完成基本的算术运算。\n\n加法运算符：x + y\n减法运算符： x - y\n乘法运算符： x * y\n除法运算符：x / y\n指数运算符：x ** y\n余数运算符：x % y\n自增运算符：++x 或者 x++\n自减运算符：--x 或者 x--\n数值运算符： +x\n负数值运算符：-x\n\n减法、乘法、除法运算法比较单纯，就是执行相应的数学运算。下面介绍其他几个算术运算符，重点是加法运算符。\n加法运算符基本规则加法运算符（+）是最常见的运算符，用来求两个数值的和。\n1 + 1 // 2\n\nJavaScript 允许非数值的相加。\ntrue + true // 21 + true // 2\n\n上面代码中，第一行是两个布尔值相加，第二行是数值与布尔值相加。这两种情况，布尔值都会自动转成数值，然后再相加。\n比较特殊的是，如果是两个字符串相加，这时加法运算符会变成连接运算符，返回一个新的字符串，将两个原字符串连接在一起。\n&#x27;a&#x27; + &#x27;bc&#x27; // &quot;abc&quot;\n\n如果一个运算子是字符串，另一个运算子是非字符串，这时非字符串会转成字符串，再连接在一起。\n1 + &#x27;a&#x27; // &quot;1a&quot;false + &#x27;a&#x27; // &quot;falsea&quot;\n\n加法运算符是在运行时决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“重载”（overload）。由于加法运算符存在重载，可能执行两种运算，使用的时候必须很小心。\n&#x27;3&#x27; + 4 + 5 // &quot;345&quot;3 + 4 + &#x27;5&#x27; // &quot;75&quot;\n\n上面代码中，由于从左到右的运算次序，字符串的位置不同会导致不同的结果。\n除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算。\n1 - &#x27;2&#x27; // -11 * &#x27;2&#x27; // 21 / &#x27;2&#x27; // 0.5\n\n上面代码中，减法、除法和乘法运算符，都是将字符串自动转为数值，然后再运算。\n对象的相加如果运算子是对象，必须先转成原始类型的值，然后再相加。\nvar obj = &#123; p: 1 &#125;;obj + 2 // &quot;[object Object]2&quot;\n\n上面代码中，对象obj转成原始类型的值是[object Object]，再加2就得到了上面的结果。\n对象转成原始类型的值，规则如下。\n首先，自动调用对象的valueOf方法。\nvar obj = &#123; p: 1 &#125;;obj.valueOf() // &#123; p: 1 &#125;\n\n一般来说，对象的valueOf方法总是返回对象自身，这时再自动调用对象的toString方法，将其转为字符串。\nvar obj = &#123; p: 1 &#125;;obj.valueOf().toString() // &quot;[object Object]&quot;\n\n对象的toString方法默认返回[object Object]，所以就得到了最前面那个例子的结果。\n知道了这个规则以后，就可以自己定义valueOf方法或toString方法，得到想要的结果。\nvar obj = &#123;  valueOf: function () &#123;    return 1;  &#125;&#125;;obj + 2 // 3\n\n上面代码中，我们定义obj对象的valueOf方法返回1，于是obj + 2就得到了3。这个例子中，由于valueOf方法直接返回一个原始类型的值，所以不再调用toString方法。\n下面是自定义toString方法的例子。\nvar obj = &#123;  toString: function () &#123;    return &#x27;hello&#x27;;  &#125;&#125;;obj + 2 // &quot;hello2&quot;\n\n上面代码中，对象obj的toString方法返回字符串hello。前面说过，只要有一个运算子是字符串，加法运算符就变成连接运算符，返回连接后的字符串。\n这里有一个特例，如果运算子是一个Date对象的实例，那么会优先执行toString方法。\nvar obj = new Date();obj.valueOf = function () &#123; return 1 &#125;;obj.toString = function () &#123; return &#x27;hello&#x27; &#125;;obj + 2 // &quot;hello2&quot;\n\n上面代码中，对象obj是一个Date对象的实例，并且自定义了valueOf方法和toString方法，结果toString方法优先执行。\n余数运算符余数运算符（%）返回前一个运算子被后一个运算子除，所得的余数。\n12 % 5 // 2\n\n需要注意的是，运算结果的正负号由第一个运算子的正负号决定。\n-1 % 2 // -11 % -2 // 1\n\n所以，为了得到负数的正确余数值，可以先使用绝对值函数。\n// 错误的写法function isOdd(n) &#123;  return n % 2 === 1;&#125;isOdd(-5) // falseisOdd(-4) // false// 正确的写法function isOdd(n) &#123;  return Math.abs(n % 2) === 1;&#125;isOdd(-5) // trueisOdd(-4) // false\n\n余数运算符还可以用于浮点数的运算。但是，由于浮点数不是精确的值，无法得到完全准确的结果。\n6.5 % 2.1// 0.19999999999999973\n\n自增和自减运算符自增和自减运算符，是一元运算符，只需要一个运算子。它们的作用是将运算子首先转为数值，然后加上1或者减去1。它们会修改原始变量。\nvar x = 1;++x // 2x // 2--x // 1x // 1\n\n上面代码的变量x自增后，返回2，再进行自减，返回1。这两种情况都会使得，原始变量x的值发生改变。\n运算之后，变量的值发生变化，这种效应叫做运算的副作用（side effect）。自增和自减运算符是仅有的两个具有副作用的运算符，其他运算符都不会改变变量的值。\n自增和自减运算符有一个需要注意的地方，就是放在变量之后，会先返回变量操作前的值，再进行自增&#x2F;自减操作；放在变量之前，会先进行自增&#x2F;自减操作，再返回变量操作后的值。\nvar x = 1;var y = 1;x++ // 1++y // 2\n\n上面代码中，x是先返回当前值，然后自增，所以得到1；y是先自增，然后返回新的值，所以得到2。\n数值运算符，负数值运算符数值运算符（+）同样使用加号，但它是一元运算符（只需要一个操作数），而加法运算符是二元运算符（需要两个操作数）。\n数值运算符的作用在于可以将任何值转为数值（与Number函数的作用相同）。\n+true // 1+[] // 0+&#123;&#125; // NaN\n\n上面代码表示，非数值经过数值运算符以后，都变成了数值（最后一行NaN也是数值）。具体的类型转换规则，参见《数据类型转换》一章。\n负数值运算符（-），也同样具有将一个值转为数值的功能，只不过得到的值正负相反。连用两个负数值运算符，等同于数值运算符。\nvar x = 1;-x // -1-(-x) // 1\n\n上面代码最后一行的圆括号不可少，否则会变成自减运算符。\n数值运算符号和负数值运算符，都会返回一个新的值，而不会改变原始变量的值。\n指数运算符指数运算符（**）完成指数运算，前一个运算子是底数，后一个运算子是指数。\n2 ** 4 // 16\n\n注意，指数运算符是右结合，而不是左结合。即多个指数运算符连用时，先进行最右边的计算。\n// 相当于 2 ** (3 ** 2)2 ** 3 ** 2// 512\n\n上面代码中，由于指数运算符是右结合，所以先计算第二个指数运算符，而不是第一个。\n赋值运算符赋值运算符（Assignment Operators）用于给变量赋值。\n最常见的赋值运算符，当然就是等号（=）。\n// 将 1 赋值给变量 xvar x = 1;// 将变量 y 的值赋值给变量 xvar x = y;\n\n赋值运算符还可以与其他运算符结合，形成变体。下面是与算术运算符的结合。\n// 等同于 x = x + yx += y// 等同于 x = x - yx -= y// 等同于 x = x * yx *= y// 等同于 x = x / yx /= y// 等同于 x = x % yx %= y// 等同于 x = x ** yx **= y\n\n下面是与位运算符的结合（关于位运算符，请见后文的介绍）。\n// 等同于 x = x &gt;&gt; yx &gt;&gt;= y// 等同于 x = x &lt;&lt; yx &lt;&lt;= y// 等同于 x = x &gt;&gt;&gt; yx &gt;&gt;&gt;= y// 等同于 x = x &amp; yx &amp;= y// 等同于 x = x | yx |= y// 等同于 x = x ^ yx ^= y\n\n这些复合的赋值运算符，都是先进行指定运算，然后将得到值返回给左边的变量。\n\n未完待续\n","tags":["教程","JavaScript"]},{"title":"从零开始学JavaScript（010 数组）","url":"/2023/08/19/js010/","content":"数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。\n\n数组定义数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。\nvar arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];\n\n上面代码中的a、b、c就构成一个数组，两端的方括号是数组的标志。a是0号位置，b是1号位置，c是2号位置。\n除了在定义时赋值，数组也可以先定义后赋值。\nvar arr = [];arr[0] = &#x27;a&#x27;;arr[1] = &#x27;b&#x27;;arr[2] = &#x27;c&#x27;;\n\n任何类型的数据，都可以放入数组。\nvar arr = [  &#123;a: 1&#125;,  [1, 2, 3],  function() &#123;return true;&#125;];arr[0] // Object &#123;a: 1&#125;arr[1] // [1, 2, 3]arr[2] // function ()&#123;return true;&#125;\n\n上面数组arr的3个成员依次是对象、数组、函数。\n如果数组的元素还是数组，就形成了多维数组。\nvar a = [[1, 2], [3, 4]];a[0][1] // 2a[1][1] // 4\n\n数组的本质本质上，数组属于一种特殊的对象。typeof运算符会返回数组的类型是object。\ntypeof [1, 2, 3] // &quot;object&quot;\n\n上面代码表明，typeof运算符认为数组的类型就是对象。\n数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2…）。\nvar arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];Object.keys(arr)// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]\n\n上面代码中，Object.keys方法返回数组的所有键名。可以看到数组的键名就是整数0、1、2。\n由于数组成员的键名是固定的（默认总是0、1、2…），因此数组不用为每个元素指定键名，而对象的每个成员都必须指定键名。JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。\nvar arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];arr[&#x27;0&#x27;] // &#x27;a&#x27;arr[0] // &#x27;a&#x27;\n\n上面代码分别用数值和字符串作为键名，结果都能读取数组。原因是数值键名被自动转为了字符串。\n注意，这点在赋值时也成立。一个值总是先转成字符串，再作为键名进行赋值。\nvar a = [];a[1.00] = 6;a[1] // 6\n\n上面代码中，由于1.00转成字符串是1，所以通过数字键1可以读取值。\n上一章说过，对象有两种读取成员的方法：点结构（object.key）和方括号结构（object[key]）。但是，对于数值的键名，不能使用点结构。\nvar arr = [1, 2, 3];arr.0 // SyntaxError\n\n上面代码中，arr.0的写法不合法，因为单独的数值不能作为标识符（identifier）。所以，数组成员只能用方括号arr[0]表示（方括号是运算符，可以接受数值）。\nlength 属性数组的length属性，返回数组的成员数量。\n[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;].length // 3\n\nJavaScript 使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有 4294967295 个（232 - 1）个，也就是说length属性的最大值就是 4294967295。\n只要是数组，就一定有length属性。该属性是一个动态的值，等于键名中的最大整数加上1。\nvar arr = [&#x27;a&#x27;, &#x27;b&#x27;];arr.length // 2arr[2] = &#x27;c&#x27;;arr.length // 3arr[9] = &#x27;d&#x27;;arr.length // 10arr[1000] = &#x27;e&#x27;;arr.length // 1001\n\n上面代码表示，数组的数字键不需要连续，length属性的值总是比最大的那个整数键大1。另外，这也表明数组是一种动态的数据结构，可以随时增减数组的成员。\nlength属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员数量会自动减少到length设置的值。\nvar arr = [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ];arr.length // 3arr.length = 2;arr // [&quot;a&quot;, &quot;b&quot;]\n\n上面代码表示，当数组的length属性设为2（即最大的整数键只能是1）那么整数键2（值为c）就已经不在数组中了，被自动删除了。\n清空数组的一个有效方法，就是将length属性设为0。\nvar arr = [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ];arr.length = 0;arr // []\n\n如果人为设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。\nvar a = [&#x27;a&#x27;];a.length = 3;a[1] // undefined\n\n上面代码表示，当length属性设为大于数组个数时，读取新增的位置都会返回undefined。\n如果人为设置length为不合法的值，JavaScript 会报错。\n// 设置负值[].length = -1// RangeError: Invalid array length// 数组元素个数大于等于2的32次方[].length = Math.pow(2, 32)// RangeError: Invalid array length// 设置字符串[].length = &#x27;abc&#x27;// RangeError: Invalid array length\n\n值得注意的是，由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响length属性的值。\nvar a = [];a[&#x27;p&#x27;] = &#x27;abc&#x27;;a.length // 0a[2.1] = &#x27;abc&#x27;;a.length // 0\n\n上面代码将数组的键分别设为字符串和小数，结果都不影响length属性。因为，length属性的值就是等于最大的数字键加1，而这个数组没有整数键，所以length属性保持为0。\n如果数组的键名是添加超出范围的数值，该键名会自动转为字符串。\nvar arr = [];arr[-1] = &#x27;a&#x27;;arr[Math.pow(2, 32)] = &#x27;b&#x27;;arr.length // 0arr[-1] // &quot;a&quot;arr[4294967296] // &quot;b&quot;\n\n上面代码中，我们为数组arr添加了两个不合法的数字键，结果length属性没有发生变化。这些数字键都变成了字符串键名。最后两行之所以会取到值，是因为取键值时，数字键名会默认转为字符串。\nin 运算符检查某个键名是否存在的运算符in，适用于对象，也适用于数组。\nvar arr = [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ];2 in arr  // true&#x27;2&#x27; in arr // true4 in arr // false\n\n上面代码表明，数组存在键名为2的键。由于键名都是字符串，所以数值2会自动转成字符串。\n注意，如果数组的某个位置是空位，in运算符返回false。\nvar arr = [];arr[100] = &#x27;a&#x27;;100 in arr // true1 in arr // false\n\n上面代码中，数组arr只有一个成员arr[100]，其他位置的键名都会返回false。\nfor…in 循环和数组的遍历for...in循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。\nvar a = [1, 2, 3];for (var i in a) &#123;  console.log(a[i]);&#125;// 1// 2// 3\n\n但是，for...in不仅会遍历数组所有的数字键，还会遍历非数字键。\nvar a = [1, 2, 3];a.foo = true;for (var key in a) &#123;  console.log(key);&#125;// 0// 1// 2// foo\n\n上面代码在遍历数组时，也遍历到了非整数键foo。所以，不推荐使用for...in遍历数组。\n数组的遍历可以考虑使用for循环或while循环。\nvar a = [1, 2, 3];// for循环for(var i = 0; i &lt; a.length; i++) &#123;  console.log(a[i]);&#125;// while循环var i = 0;while (i &lt; a.length) &#123;  console.log(a[i]);  i++;&#125;var l = a.length;while (l--) &#123;  console.log(a[l]);&#125;\n\n上面代码是三种遍历数组的写法。最后一种写法是逆向遍历，即从最后一个元素向第一个元素遍历。\n数组的forEach方法，也可以用来遍历数组，详见《标准库》的 Array 对象一章。\nvar colors = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;];colors.forEach(function (color) &#123;  console.log(color);&#125;);// red// green// blue\n\n数组的空位当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。\nvar a = [1, , 1];a.length // 3\n\n上面代码表明，数组的空位不影响length属性。虽然这个位置没有值，引擎依然认为这个位置是有效的。\n需要注意的是，如果最后一个元素后面有逗号，并不会产生空位。也就是说，有没有这个逗号，结果都是一样的。\nvar a = [1, 2, 3,];a.length // 3a // [1, 2, 3]\n\n上面代码中，数组最后一个成员后面有一个逗号，这不影响length属性的值，与没有这个逗号时效果一样。\n数组的空位是可以读取的，返回undefined。\nvar a = [, , ,];a[1] // undefined\n\n使用delete命令删除一个数组成员，会形成空位，并且不会影响length属性。\nvar a = [1, 2, 3];delete a[1];a[1] // undefineda.length // 3\n\n上面代码用delete命令删除了数组的第二个元素，这个位置就形成了空位，但是对length属性没有影响。也就是说，length属性不过滤空位。所以，使用length属性进行数组遍历，一定要非常小心。\n数组的某个位置是空位，与某个位置是undefined，是不一样的。如果是空位，使用数组的forEach方法、for...in结构、以及Object.keys方法进行遍历，空位都会被跳过。\nvar a = [, , ,];a.forEach(function (x, i) &#123;  console.log(i + &#x27;. &#x27; + x);&#125;)// 不产生任何输出for (var i in a) &#123;  console.log(i);&#125;// 不产生任何输出Object.keys(a)// []\n\n如果某个位置是undefined，遍历的时候就不会被跳过。\nvar a = [undefined, undefined, undefined];a.forEach(function (x, i) &#123;  console.log(i + &#x27;. &#x27; + x);&#125;);// 0. undefined// 1. undefined// 2. undefinedfor (var i in a) &#123;  console.log(i);&#125;// 0// 1// 2Object.keys(a)// [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;]\n\n这就是说，空位就是数组没有这个元素，所以不会被遍历到，而undefined则表示数组有这个元素，值是undefined，所以遍历不会跳过。\n类似数组的对象如果一个对象的所有键名都是正整数或零，并且有length属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。\nvar obj = &#123;  0: &#x27;a&#x27;,  1: &#x27;b&#x27;,  2: &#x27;c&#x27;,  length: 3&#125;;obj[0] // &#x27;a&#x27;obj[1] // &#x27;b&#x27;obj.length // 3obj.push(&#x27;d&#x27;) // TypeError: obj.push is not a function\n\n上面代码中，对象obj就是一个类似数组的对象。但是，“类似数组的对象”并不是数组，因为它们不具备数组特有的方法。对象obj没有数组的push方法，使用该方法就会报错。\n“类似数组的对象”的根本特征，就是具有length属性。只要有length属性，就可以认为这个对象类似于数组。但是有一个问题，这种length属性不是动态值，不会随着成员的变化而变化。\nvar obj = &#123;  length: 0&#125;;obj[3] = &#x27;d&#x27;;obj.length // 0\n\n上面代码为对象obj添加了一个数字键，但是length属性没变。这就说明了obj不是数组。\n典型的“类似数组的对象”是函数的arguments对象，以及大多数 DOM 元素集，还有字符串。\n// arguments对象function args() &#123; return arguments &#125;var arrayLike = args(&#x27;a&#x27;, &#x27;b&#x27;);arrayLike[0] // &#x27;a&#x27;arrayLike.length // 2arrayLike instanceof Array // false// DOM元素集var elts = document.getElementsByTagName(&#x27;h3&#x27;);elts.length // 3elts instanceof Array // false// 字符串&#x27;abc&#x27;[1] // &#x27;b&#x27;&#x27;abc&#x27;.length // 3&#x27;abc&#x27; instanceof Array // false\n\n上面代码包含三个例子，它们都不是数组（instanceof运算符返回false），但是看上去都非常像数组。\n数组的slice方法可以将“类似数组的对象”变成真正的数组。\nvar arr = Array.prototype.slice.call(arrayLike);\n\n除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过call()把数组的方法放到对象上面。\nfunction print(value, index) &#123;  console.log(index + &#x27; : &#x27; + value);&#125;Array.prototype.forEach.call(arrayLike, print);\n\n上面代码中，arrayLike代表一个类似数组的对象，本来是不可以使用数组的forEach()方法的，但是通过call()，可以把forEach()嫁接到arrayLike上面调用。\n下面的例子就是通过这种方法，在arguments对象上面调用forEach方法。\n// forEach 方法function logArgs() &#123;  Array.prototype.forEach.call(arguments, function (elem, i) &#123;    console.log(i + &#x27;. &#x27; + elem);  &#125;);&#125;// 等同于 for 循环function logArgs() &#123;  for (var i = 0; i &lt; arguments.length; i++) &#123;    console.log(i + &#x27;. &#x27; + arguments[i]);  &#125;&#125;\n\n字符串也是类似数组的对象，所以也可以用Array.prototype.forEach.call遍历。\nArray.prototype.forEach.call(&#x27;abc&#x27;, function (chr) &#123;  console.log(chr);&#125;);// a// b// c\n\n注意，这种方法比直接使用数组原生的forEach要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的forEach方法。\nvar arr = Array.prototype.slice.call(&#x27;abc&#x27;);arr.forEach(function (chr) &#123;  console.log(chr);&#125;);// a// b// c\n\n参考链接\nAxel Rauschmayer, Arrays in JavaScript\nAxel Rauschmayer, JavaScript: sparse arrays vs. dense arrays\nFelix Bohm, What They Didn’t Tell You About ES5′s Array Extras\nJuriy Zaytsev, How ECMAScript 5 still does not allow to subclass an array\n\n\n未完待续\n","tags":["教程","JavaScript"]},{"title":"从零开始学JavaScript（012 比较运算符）","url":"/2023/08/21/js012/","content":"比较运算符用于比较两个值的大小，然后返回一个布尔值，表示是否满足指定的条件。\n\n比较运算符概述比较运算符用于比较两个值的大小，然后返回一个布尔值，表示是否满足指定的条件。\n2 &gt; 1 // true\n\n上面代码比较2是否大于1，返回true。\n\n注意，比较运算符可以比较各种类型的值，不仅仅是数值。\n\nJavaScript 一共提供了8个比较运算符。\n\n&gt; 大于运算符\n&lt; 小于运算符\n&lt;= 小于或等于运算符\n&gt;= 大于或等于运算符\n== 相等运算符\n=== 严格相等运算符\n!= 不相等运算符\n!== 严格不相等运算符\n\n这八个比较运算符分成两类：相等比较和非相等比较。两者的规则是不一样的，对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；否则，将两个运算子都转成数值，再比较数值的大小。\n非相等运算符：字符串的比较字符串按照字典顺序进行比较。\n&#x27;cat&#x27; &gt; &#x27;dog&#x27; // false&#x27;cat&#x27; &gt; &#x27;catalog&#x27; // false\n\nJavaScript 引擎内部首先比较首字符的 Unicode 码点。如果相等，再比较第二个字符的 Unicode 码点，以此类推。\n&#x27;cat&#x27; &gt; &#x27;Cat&#x27; // true&#x27;\n\n上面代码中，小写的c的 Unicode 码点（99）大于大写的C的 Unicode 码点（67），所以返回true。\n由于所有字符都有 Unicode 码点，因此汉字也可以比较。\n&#x27;大&#x27; &gt; &#x27;小&#x27; // false\n\n上面代码中，“大”的 Unicode 码点是22823，“小”是23567，因此返回false。\n非相等运算符：非字符串的比较如果两个运算子之中，至少有一个不是字符串，需要分成以下两种情况。\n（1）原始类型值\n如果两个运算子都是原始类型的值，则是先转成数值再比较。\n5 &gt; &#x27;4&#x27; // true// 等同于 5 &gt; Number(&#x27;4&#x27;)// 即 5 &gt; 4true &gt; false // true// 等同于 Number(true) &gt; Number(false)// 即 1 &gt; 02 &gt; true // true// 等同于 2 &gt; Number(true)// 即 2 &gt; 1\n\n上面代码中，字符串和布尔值都会先转成数值，再进行比较。\n这里需要注意与NaN的比较。任何值（包括NaN本身）与NaN使用非相等运算符进行比较，返回的都是false。\n1 &gt; NaN // false1 &lt;= NaN // false&#x27;1&#x27; &gt; NaN // false&#x27;1&#x27; &lt;= NaN // falseNaN &gt; NaN // falseNaN &lt;= NaN // false\n\n（2）对象\n如果运算子是对象，会转为原始类型的值，再进行比较。\n对象转换成原始类型的值，算法是先调用valueOf方法；如果返回的还是对象，再接着调用toString方法，详细解释参见《数据类型的转换》一章。\nvar x = [2];x &gt; &#x27;11&#x27; // true// 等同于 [2].valueOf().toString() &gt; &#x27;11&#x27;// 即 &#x27;2&#x27; &gt; &#x27;11&#x27;x.valueOf = function () &#123; return &#x27;1&#x27; &#125;;x &gt; &#x27;11&#x27; // false// 等同于 (function () &#123; return &#x27;1&#x27; &#125;)() &gt; &#x27;11&#x27;// 即 &#x27;1&#x27; &gt; &#x27;11&#x27;\n\n两个对象之间的比较也是如此。\n[2] &gt; [1] // true// 等同于 [2].valueOf().toString() &gt; [1].valueOf().toString()// 即 &#x27;2&#x27; &gt; &#x27;1&#x27;[2] &gt; [11] // true// 等同于 [2].valueOf().toString() &gt; [11].valueOf().toString()// 即 &#x27;2&#x27; &gt; &#x27;11&#x27;(&#123; x: 2 &#125;) &gt;= (&#123; x: 1 &#125;) // true// 等同于 (&#123; x: 2 &#125;).valueOf().toString() &gt;= (&#123; x: 1 &#125;).valueOf().toString()// 即 &#x27;[object Object]&#x27; &gt;= &#x27;[object Object]&#x27;\n\n严格相等运算符JavaScript 提供两种相等运算符：==和===。\n简单说，它们的区别是相等运算符（==）比较两个值是否相等，严格相等运算符（===）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（===）直接返回false，而相等运算符（==）会将它们转换成同一个类型，再用严格相等运算符进行比较。\n本节介绍严格相等运算符的算法。\n（1）不同类型的值\n如果两个值的类型不同，直接返回false。\n1 === &quot;1&quot; // falsetrue === &quot;true&quot; // false\n\n上面代码比较数值的1与字符串的“1”、布尔值的true与字符串&quot;true&quot;，因为类型不同，结果都是false。\n（2）同一类的原始类型值\n同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false。\n1 === 0x1 // true\n\n上面代码比较十进制的1与十六进制的1，因为类型和值都相同，返回true。\n需要注意的是，NaN与任何值都不相等（包括自身）。另外，正0等于负0。\nNaN === NaN  // false+0 === -0 // true\n\n（3）复合类型值\n两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。\n&#123;&#125; === &#123;&#125; // false[] === [] // false(function () &#123;&#125; === function () &#123;&#125;) // false\n\n上面代码分别比较两个空对象、两个空数组、两个空函数，结果都是不相等。原因是对于复合类型的值，严格相等运算比较的是，它们是否引用同一个内存地址，而运算符两边的空对象、空数组、空函数的值，都存放在不同的内存地址，结果当然是false。\n如果两个变量引用同一个对象，则它们相等。\nvar v1 = &#123;&#125;;var v2 = v1;v1 === v2 // true\n\n注意，对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值。\nvar obj1 = &#123;&#125;;var obj2 = &#123;&#125;;obj1 &gt; obj2 // falseobj1 &lt; obj2 // falseobj1 === obj2 // false\n\n上面的三个比较，前两个比较的是值，最后一个比较的是地址，所以都返回false。\n（4）undefined 和 null\nundefined和null与自身严格相等。\nundefined === undefined // truenull === null // true\n\n由于变量声明后默认值是undefined，因此两个只声明未赋值的变量是相等的。\nvar v1;var v2;v1 === v2 // true\n\n严格不相等运算符严格相等运算符有一个对应的“严格不相等运算符”（!==），它的算法就是先求严格相等运算符的结果，然后返回相反值。\n1 !== &#x27;1&#x27; // true// 等同于!(1 === &#x27;1&#x27;)\n\n上面代码中，感叹号!是求出后面表达式的相反值。\n相等运算符相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样。\n1 == 1.0// 等同于1 === 1.0\n\n比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。下面分成几种情况，讨论不同类型的值互相比较的规则。\n（1）原始类型值\n原始类型的值会转换成数值再进行比较。\n1 == true // true// 等同于 1 === Number(true)0 == false // true// 等同于 0 === Number(false)2 == true // false// 等同于 2 === Number(true)2 == false // false// 等同于 2 === Number(false)&#x27;true&#x27; == true // false// 等同于 Number(&#x27;true&#x27;) === Number(true)// 等同于 NaN === 1&#x27;&#x27; == 0 // true// 等同于 Number(&#x27;&#x27;) === 0// 等同于 0 === 0&#x27;&#x27; == false  // true// 等同于 Number(&#x27;&#x27;) === Number(false)// 等同于 0 === 0&#x27;1&#x27; == true  // true// 等同于 Number(&#x27;1&#x27;) === Number(true)// 等同于 1 === 1&#x27;\\n  123  \\t&#x27; == 123 // true// 因为字符串转为数字时，省略前置和后置的空格\n\n上面代码将字符串和布尔值都转为数值，然后再进行比较。具体的字符串与布尔值的类型转换规则，参见《数据类型转换》一章。\n（2）对象与原始类型值比较\n对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较。\n具体来说，先调用对象的valueOf()方法，如果得到原始类型的值，就按照上一小节的规则，互相比较；如果得到的还是对象，则再调用toString()方法，得到字符串形式，再进行比较。\n下面是数组与原始类型值比较的例子。\n// 数组与数值的比较[1] == 1 // true// 数组与字符串的比较[1] == &#x27;1&#x27; // true[1, 2] == &#x27;1,2&#x27; // true// 对象与布尔值的比较[1] == true // true[2] == true // false\n\n上面例子中，JavaScript 引擎会先对数组[1]调用数组的valueOf()方法，由于返回的还是一个数组，所以会接着调用数组的toString()方法，得到字符串形式，再按照上一小节的规则进行比较。\n下面是一个更直接的例子。\nconst obj = &#123;  valueOf: function () &#123;    console.log(&#x27;执行 valueOf()&#x27;);    return obj;  &#125;,  toString: function () &#123;    console.log(&#x27;执行 toString()&#x27;);    return &#x27;foo&#x27;;  &#125;&#125;;obj == &#x27;foo&#x27;// 执行 valueOf()// 执行 toString()// true\n\n上面例子中，obj是一个自定义了valueOf()和toString()方法的对象。这个对象与字符串&#39;foo&#39;进行比较时，会依次调用valueOf()和toString()方法，最后返回&#39;foo&#39;，所以比较结果是true。\n（3）undefined 和 null\nundefined和null只有与自身比较，或者互相比较时，才会返回true；与其他类型的值比较时，结果都为false。\nundefined == undefined // truenull == null // trueundefined == null // truefalse == null // falsefalse == undefined // false0 == null // false0 == undefined // false\n\n（4）相等运算符的缺点\n相等运算符隐藏的类型转换，会带来一些违反直觉的结果。\n0 == &#x27;&#x27;             // true0 == &#x27;0&#x27;            // true2 == true           // false2 == false          // falsefalse == &#x27;false&#x27;    // falsefalse == &#x27;0&#x27;        // truefalse == undefined  // falsefalse == null       // falsenull == undefined   // true&#x27; \\t\\r\\n &#x27; == 0     // true\n\n上面这些表达式都不同于直觉，很容易出错。因此建议不要使用相等运算符（==），最好只使用严格相等运算符（===）。\n不相等运算符相等运算符有一个对应的“不相等运算符”（!=），它的算法就是先求相等运算符的结果，然后返回相反值。\n1 != &#x27;1&#x27; // false// 等同于!(1 == &#x27;1&#x27;)\n\n\n未完待续\n","tags":["教程","JavaScript"]},{"title":"从零开始学JavaScript（013 布尔运算符）","url":"/2023/08/21/js013/","content":"\n布尔运算符用于将表达式转为布尔值，一共包含四个运算符。\n\n布尔运算符概述布尔运算符用于将表达式转为布尔值，一共包含四个运算符。\n\n取反运算符：!\n且运算符：&amp;&amp;\n或运算符：||\n三元运算符：?:\n\n取反运算符（!）取反运算符是一个感叹号，用于将布尔值变为相反值，即true变成false，false变成true。\n!true // false!false // true\n\n对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为true，其他值都为false。\n\nundefined\nnull\nfalse\n0\nNaN\n空字符串（&#39;&#39;）\n\n!undefined // true!null // true!0 // true!NaN // true!&quot;&quot; // true!54 // false!&#x27;hello&#x27; // false![] // false!&#123;&#125; // false\n\n上面代码中，不管什么类型的值，经过取反运算后，都变成了布尔值。\n如果对一个值连续做两次取反运算，等于将其转为对应的布尔值，与Boolean函数的作用相同。这是一种常用的类型转换的写法。\n!!x// 等同于Boolean(x)\n\n上面代码中，不管x是什么类型的值，经过两次取反运算后，变成了与Boolean函数结果相同的布尔值。所以，两次取反就是将一个值转为布尔值的简便写法。\n且运算符（&amp;&amp;）且运算符（&amp;&amp;）往往用于多个表达式的求值。\n它的运算规则是：如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。\n&#x27;t&#x27; &amp;&amp; &#x27;&#x27; // &quot;&quot;&#x27;t&#x27; &amp;&amp; &#x27;f&#x27; // &quot;f&quot;&#x27;t&#x27; &amp;&amp; (1 + 2) // 3&#x27;&#x27; &amp;&amp; &#x27;f&#x27; // &quot;&quot;&#x27;&#x27; &amp;&amp; &#x27;&#x27; // &quot;&quot;var x = 1;(1 - 1) &amp;&amp; ( x += 1) // 0x // 1\n\n上面代码的最后一个例子，由于且运算符的第一个运算子的布尔值为false，则直接返回它的值0，而不再对第二个运算子求值，所以变量x的值没变。\n这种跳过第二个运算子的机制，被称为“短路”。有些程序员喜欢用它取代if结构，比如下面是一段if结构的代码，就可以用且运算符改写。\nif (i) &#123;  doSomething();&#125;// 等价于i &amp;&amp; doSomething();\n\n上面代码的两种写法是等价的，但是后一种不容易看出目的，也不容易除错，建议谨慎使用。\n且运算符可以多个连用，这时返回第一个布尔值为false的表达式的值。如果所有表达式的布尔值都为true，则返回最后一个表达式的值。\ntrue &amp;&amp; &#x27;foo&#x27; &amp;&amp; &#x27;&#x27; &amp;&amp; 4 &amp;&amp; &#x27;foo&#x27; &amp;&amp; true// &#x27;&#x27;1 &amp;&amp; 2 &amp;&amp; 3// 3\n\n上面代码中，例一里面，第一个布尔值为false的表达式为第三个表达式，所以得到一个空字符串。例二里面，所有表达式的布尔值都是true，所以返回最后一个表达式的值3。\n或运算符（||）或运算符（||）也用于多个表达式的求值。它的运算规则是：如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。\n&#x27;t&#x27; || &#x27;&#x27; // &quot;t&quot;&#x27;t&#x27; || &#x27;f&#x27; // &quot;t&quot;&#x27;&#x27; || &#x27;f&#x27; // &quot;f&quot;&#x27;&#x27; || &#x27;&#x27; // &quot;&quot;\n\n短路规则对这个运算符也适用。\nvar x = 1;true || (x = 2) // truex // 1\n\n上面代码中，或运算符的第一个运算子为true，所以直接返回true，不再运行第二个运算子。所以，x的值没有改变。这种只通过第一个表达式的值，控制是否运行第二个表达式的机制，就称为“短路”（short-cut）。\n或运算符可以多个连用，这时返回第一个布尔值为true的表达式的值。如果所有表达式都为false，则返回最后一个表达式的值。\nfalse || 0 || &#x27;&#x27; || 4 || &#x27;foo&#x27; || true// 4false || 0 || &#x27;&#x27;// &#x27;&#x27;\n\n上面代码中，例一里面，第一个布尔值为true的表达式是第四个表达式，所以得到数值4。例二里面，所有表达式的布尔值都为false，所以返回最后一个表达式的值。\n或运算符常用于为一个变量设置默认值。\nfunction saveText(text) &#123;  text = text || &#x27;&#x27;;  // ...&#125;// 或者写成saveText(this.text || &#x27;&#x27;)\n\n上面代码表示，如果函数调用时，没有提供参数，则该参数默认设置为空字符串。\n三元条件运算符（?:）三元条件运算符由问号（?）和冒号（:）组成，分隔三个表达式。它是 JavaScript 语言唯一一个需要三个运算子的运算符。如果第一个表达式的布尔值为true，则返回第二个表达式的值，否则返回第三个表达式的值。\n&#x27;t&#x27; ? &#x27;hello&#x27; : &#x27;world&#x27; // &quot;hello&quot;0 ? &#x27;hello&#x27; : &#x27;world&#x27; // &quot;world&quot;\n\n上面代码的t和0的布尔值分别为true和false，所以分别返回第二个和第三个表达式的值。\n通常来说，三元条件表达式与if...else语句具有同样表达效果，前者可以表达的，后者也能表达。但是两者具有一个重大差别，if...else是语句，没有返回值；三元条件表达式是表达式，具有返回值。所以，在需要返回值的场合，只能使用三元条件表达式，而不能使用if..else。\nconsole.log(true ? &#x27;T&#x27; : &#x27;F&#x27;);\n\n上面代码中，console.log方法的参数必须是一个表达式，这时就只能使用三元条件表达式。如果要用if...else语句，就必须改变整个代码写法了。\n\n未完待续\n","tags":["教程","JavaScript"]},{"title":"从零开始学JavaScript（014 二进制位运算符）","url":"/2023/08/21/js014/","content":"\n二进制位运算符用于直接对二进制位进行计算，一共有7个。\n\n二进制位运算符概述\n二进制或运算符（or）：符号为|，表示若两个二进制位都为0，则结果为0，否则为1。\n二进制与运算符（and）：符号为&amp;，表示若两个二进制位都为1，则结果为1，否则为0。\n二进制否运算符（not）：符号为~，表示对一个二进制位取反。\n异或运算符（xor）：符号为^，表示若两个二进制位不相同，则结果为1，否则为0。\n左移运算符（left shift）：符号为&lt;&lt;，详见下文解释。\n右移运算符（right shift）：符号为&gt;&gt;，详见下文解释。\n头部补零的右移运算符（zero filled right shift）：符号为&gt;&gt;&gt;，详见下文解释。\n\n这些位运算符直接处理每一个比特位（bit），所以是非常底层的运算，好处是速度极快，缺点是很不直观，许多场合不能使用它们，否则会使代码难以理解和查错。\n有一点需要特别注意，位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。\ni = i | 0;\n\n上面这行代码的意思，就是将i（不管是整数或小数）转为32位整数。\n利用这个特性，可以写出一个函数，将任意数值转为32位整数。\nfunction toInt32(x) &#123;  return x | 0;&#125;\n\n上面这个函数将任意值与0进行一次或运算，这个位运算会自动将一个值转为32位整数。下面是这个函数的用法。\ntoInt32(1.001) // 1toInt32(1.999) // 1toInt32(1) // 1toInt32(-1) // -1toInt32(Math.pow(2, 32) + 1) // 1toInt32(Math.pow(2, 32) - 1) // -1\n\n上面代码中，toInt32可以将小数转为整数。对于一般的整数，返回值不会有任何变化。对于大于或等于2的32次方的整数，大于32位的数位都会被舍去。\n二进制或运算符二进制或运算符（|）逐位比较两个运算子，两个二进制位之中只要有一个为1，就返回1，否则返回0。\n0 | 3 // 3\n\n上面代码中，0和3的二进制形式分别是00和11，所以进行二进制或运算会得到11（即3）。\n位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分。所以，将一个小数与0进行二进制或运算，等同于对该数去除小数部分，即取整数位。\n2.9 | 0 // 2-2.9 | 0 // -2\n\n需要注意的是，这种取整方法不适用超过32位整数最大值2147483647的数。\n2147483649.4 | 0;// -2147483647\n\n二进制与运算符二进制与运算符（&amp;）的规则是逐位比较两个运算子，两个二进制位之中只要有一个位为0，就返回0，否则返回1。\n0 &amp; 3 // 0\n\n上面代码中，0（二进制00）和3（二进制11）进行二进制与运算会得到00（即0）。\n二进制否运算符二进制否运算符（~）将每个二进制位都变为相反值（0变为1，1变为0）。它的返回结果有时比较难理解，因为涉及到计算机内部的数值表示机制。\n~ 3 // -4\n\n上面表达式对3进行二进制否运算，得到-4。之所以会有这样的结果，是因为位运算时，JavaScript 内部将所有的运算子都转为32位的二进制整数再进行运算。\n3的32位整数形式是00000000000000000000000000000011，二进制否运算以后得到11111111111111111111111111111100。由于第一位（符号位）是1，所以这个数是一个负数。JavaScript 内部采用补码形式表示负数，即需要将这个数减去1，再取一次反，然后加上负号，才能得到这个负数对应的10进制值。这个数减去1等于11111111111111111111111111111011，再取一次反得到00000000000000000000000000000100，再加上负号就是-4。考虑到这样的过程比较麻烦，可以简单记忆成，一个数与自身的取反值相加，等于-1。\n~ -3 // 2\n\n上面表达式可以这样算，-3的取反值等于-1减去-3，结果为2。\n对一个整数连续两次二进制否运算，得到它自身。\n~~3 // 3\n\n所有的位运算都只对整数有效。二进制否运算遇到小数时，也会将小数部分舍去，只保留整数部分。所以，对一个小数连续进行两次二进制否运算，能达到取整效果。\n~~2.9 // 2~~47.11 // 47~~1.9999 // 1~~3 // 3\n\n使用二进制否运算取整，是所有取整方法中最快的一种。\n对字符串进行二进制否运算，JavaScript 引擎会先调用Number函数，将字符串转为数值。\n// 相当于~Number(&#x27;011&#x27;)~&#x27;011&#x27;  // -12// 相当于~Number(&#x27;42 cats&#x27;)~&#x27;42 cats&#x27; // -1// 相当于~Number(&#x27;0xcafebabe&#x27;)~&#x27;0xcafebabe&#x27; // 889275713// 相当于~Number(&#x27;deadbeef&#x27;)~&#x27;deadbeef&#x27; // -1\n\nNumber函数将字符串转为数值的规则，参见《数据的类型转换》一章。\n对于其他类型的值，二进制否运算也是先用Number转为数值，然后再进行处理。\n// 相当于 ~Number([])~[] // -1// 相当于 ~Number(NaN)~NaN // -1// 相当于 ~Number(null)~null // -1\n\n异或运算符异或运算（^）在两个二进制位不同时返回1，相同时返回0。\n0 ^ 3 // 3\n\n上面表达式中，0（二进制00）与3（二进制11）进行异或运算，它们每一个二进制位都不同，所以得到11（即3）。\n“异或运算”有一个特殊运用，连续对两个数a和b进行三次异或运算，a^=b; b^=a; a^=b;，可以互换它们的值。这意味着，使用“异或运算”可以在不引入临时变量的前提下，互换两个变量的值。\nvar a = 10;var b = 99;a ^= b, b ^= a, a ^= b;a // 99b // 10\n\n这是互换两个变量的值的最快方法。\n异或运算也可以用来取整。\n12.9 ^ 0 // 12\n\n左移运算符左移运算符（&lt;&lt;）表示将一个数的二进制值向左移动指定的位数，尾部补0，即乘以2的指定次方。向左移动的时候，最高位的符号位是一起移动的。\n// 4 的二进制形式为100，// 左移一位为1000（即十进制的8）// 相当于乘以2的1次方4 &lt;&lt; 1// 8-4 &lt;&lt; 1// -8\n\n上面代码中，-4左移一位得到-8，是因为-4的二进制形式是11111111111111111111111111111100，左移一位后得到11111111111111111111111111111000，该数转为十进制（减去1后取反，再加上负号）即为-8。\n如果左移0位，就相当于将该数值转为32位整数，等同于取整，对于正数和负数都有效。\n13.5 &lt;&lt; 0// 13-13.5 &lt;&lt; 0// -13\n\n左移运算符用于二进制数值非常方便。\nvar color = &#123;r: 186, g: 218, b: 85&#125;;// RGB to HEX// (1 &lt;&lt; 24)的作用为保证结果是6位数var rgb2hex = function(r, g, b) &#123;  return &#x27;#&#x27; + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b)    .toString(16) // 先转成十六进制，然后返回字符串    .substr(1);   // 去除字符串的最高位，返回后面六个字符串&#125;rgb2hex(color.r, color.g, color.b)// &quot;#bada55&quot;\n\n上面代码使用左移运算符，将颜色的 RGB 值转为 HEX 值。\n右移运算符右移运算符（&gt;&gt;）表示将一个数的二进制值向右移动指定的位数。如果是正数，头部全部补0；如果是负数，头部全部补1。右移运算符基本上相当于除以2的指定次方（最高位即符号位参与移动）。\n4 &gt;&gt; 1// 2/*// 因为4的二进制形式为 00000000000000000000000000000100，// 右移一位得到 00000000000000000000000000000010，// 即为十进制的2*/-4 &gt;&gt; 1// -2/*// 因为-4的二进制形式为 11111111111111111111111111111100，// 右移一位，头部补1，得到 11111111111111111111111111111110,// 即为十进制的-2*/\n\n右移运算可以模拟 2 的整除运算。\n5 &gt;&gt; 1// 2// 相当于 5 / 2 = 221 &gt;&gt; 2// 5// 相当于 21 / 4 = 521 &gt;&gt; 3// 2// 相当于 21 / 8 = 221 &gt;&gt; 4// 1// 相当于 21 / 16 = 1\n\n头部补零的右移运算符头部补零的右移运算符（&gt;&gt;&gt;）与右移运算符（&gt;&gt;）只有一个差别，就是一个数的二进制形式向右移动时，头部一律补零，而不考虑符号位。所以，该运算总是得到正值。对于正数，该运算的结果与右移运算符（&gt;&gt;）完全一致，区别主要在于负数。\n4 &gt;&gt;&gt; 1// 2-4 &gt;&gt;&gt; 1// 2147483646/*// 因为-4的二进制形式为11111111111111111111111111111100，// 带符号位的右移一位，得到01111111111111111111111111111110，// 即为十进制的2147483646。*/\n\n这个运算实际上将一个值转为32位无符号整数。\n查看一个负整数在计算机内部的储存形式，最快的方法就是使用这个运算符。\n-1 &gt;&gt;&gt; 0 // 4294967295\n\n上面代码表示，-1作为32位整数时，内部的储存形式使用无符号整数格式解读，值为 4294967295（即(2^32)-1，等于11111111111111111111111111111111）。\n开关作用位运算符可以用作设置对象属性的开关。\n假定某个对象有四个开关，每个开关都是一个变量。那么，可以设置一个四位的二进制数，它的每个位对应一个开关。\nvar FLAG_A = 1; // 0001var FLAG_B = 2; // 0010var FLAG_C = 4; // 0100var FLAG_D = 8; // 1000\n\n上面代码设置 A、B、C、D 四个开关，每个开关分别占有一个二进制位。\n然后，就可以用二进制与运算，检查当前设置是否打开了指定开关。\nvar flags = 5; // 二进制的0101if (flags &amp; FLAG_C) &#123;  // ...&#125;// 0101 &amp; 0100 =&gt; 0100 =&gt; true\n\n上面代码检验是否打开了开关C。如果打开，会返回true，否则返回false。\n现在假设需要打开A、B、D三个开关，我们可以构造一个掩码变量。\nvar mask = FLAG_A | FLAG_B | FLAG_D;// 0001 | 0010 | 1000 =&gt; 1011\n\n上面代码对A、B、D三个变量进行二进制或运算，得到掩码值为二进制的1011。\n有了掩码，二进制或运算可以确保打开指定的开关。\nflags = flags | mask;\n\n上面代码中，计算后得到的flags变量，代表三个开关的二进制位都打开了。\n二进制与运算可以将当前设置中凡是与开关设置不一样的项，全部关闭。\nflags = flags &amp; mask;\n\n异或运算可以切换（toggle）当前设置，即第一次执行可以得到当前设置的相反值，再执行一次又得到原来的值。\nflags = flags ^ mask;\n\n二进制否运算可以翻转当前设置，即原设置为0，运算后变为1；原设置为1，运算后变为0。\nflags = ~flags;\n\n参考链接\nMichal Budzynski, JavaScript: The less known parts. Bitwise Operators\nAxel Rauschmayer, Basic JavaScript for the impatient programmer\nMozilla Developer Network, Bitwise Operators\n\n\n未完待续\n","tags":["教程","JavaScript"]},{"title":"从零开始学JavaScript（015 其他运算符，运算顺序）","url":"/2023/08/21/js015/","content":"本文再介绍一些其他的运算符\n\n其他运算符，运算顺序void 运算符void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。\nvoid 0 // undefinedvoid(0) // undefined\n\n上面是void运算符的两种写法，都正确。建议采用后一种形式，即总是使用圆括号。因为void运算符的优先性很高，如果不使用括号，容易造成错误的结果。比如，void 4 + 7实际上等同于(void 4) + 7。\n下面是void运算符的一个例子。\nvar x = 3;void (x = 5) //undefinedx // 5\n\n这个运算符的主要用途是浏览器的书签工具（Bookmarklet），以及在超级链接中插入代码防止网页跳转。\n请看下面的代码。\n&lt;script&gt;function f() &#123;  console.log(&#x27;Hello World&#x27;);&#125;&lt;/script&gt;&lt;a href=&quot;http://example.com&quot; onclick=&quot;f(); return false;&quot;&gt;点击&lt;/a&gt;\n\n上面代码中，点击链接后，会先执行onclick的代码，由于onclick返回false，所以浏览器不会跳转到 example.com。\nvoid运算符可以取代上面的写法。\n&lt;a href=&quot;javascript: void(f())&quot;&gt;文字&lt;/a&gt;\n\n下面是一个更实际的例子，用户点击链接提交表单，但是不产生页面跳转。\n&lt;a href=&quot;javascript: void(document.form.submit())&quot;&gt;  提交&lt;/a&gt;\n\n逗号运算符逗号运算符用于对两个表达式求值，并返回后一个表达式的值。\n&#x27;a&#x27;, &#x27;b&#x27; // &quot;b&quot;var x = 0;var y = (x++, 10);x // 1y // 10\n\n上面代码中，逗号运算符返回后一个表达式的值。\n逗号运算符的一个用途是，在返回一个值之前，进行一些辅助操作。\nvar value = (console.log(&#x27;Hi!&#x27;), true);// Hi!value // true\n\n上面代码中，先执行逗号之前的操作，然后返回逗号后面的值。\n运算顺序优先级JavaScript 各种运算符的优先级别（Operator Precedence）是不一样的。优先级高的运算符先执行，优先级低的运算符后执行。\n4 + 5 * 6 // 34\n\n上面的代码中，乘法运算符（*）的优先性高于加法运算符（+），所以先执行乘法，再执行加法，相当于下面这样。\n4 + (5 * 6) // 34\n\n如果多个运算符混写在一起，常常会导致令人困惑的代码。\nvar x = 1;var arr = [];var y = arr.length &lt;= 0 || arr[0] === undefined ? x : arr[0];\n\n上面代码中，变量y的值就很难看出来，因为这个表达式涉及5个运算符，到底谁的优先级最高，实在不容易记住。\n根据语言规格，这五个运算符的优先级从高到低依次为：小于等于（&lt;=)、严格相等（===）、或（||）、三元（?:）、等号（=）。因此上面的表达式，实际的运算顺序如下。\nvar y = ((arr.length &lt;= 0) || (arr[0] === undefined)) ? x : arr[0];\n\n记住所有运算符的优先级，是非常难的，也是没有必要的。\n圆括号的作用圆括号（()）可以用来提高运算的优先级，因为它的优先级是最高的，即圆括号中的表达式会第一个运算。\n(4 + 5) * 6 // 54\n\n上面代码中，由于使用了圆括号，加法会先于乘法执行。\n运算符的优先级别十分繁杂，且都是硬性规定，因此建议总是使用圆括号，保证运算顺序清晰可读，这对代码的维护和除错至关重要。\n顺便说一下，圆括号不是运算符，而是一种语法结构。它一共有两种用法：一种是把表达式放在圆括号之中，提升运算的优先级；另一种是跟在函数的后面，作用是调用函数。\n注意，因为圆括号不是运算符，所以不具有求值作用，只改变运算的优先级。\nvar x = 1;(x) = 2;\n\n上面代码的第二行，如果圆括号具有求值作用，那么就会变成1 = 2，这时会报错了。但是，上面的代码可以运行，这验证了圆括号只改变优先级，不会求值。\n这也意味着，如果整个表达式都放在圆括号之中，那么不会有任何效果。\n(expression)// 等同于expression\n\n函数放在圆括号中，会返回函数本身。如果圆括号紧跟在函数的后面，就表示调用函数。\nfunction f() &#123;  return 1;&#125;(f) // function f()&#123;return 1;&#125;f() // 1\n\n上面代码中，函数放在圆括号之中会返回函数本身，圆括号跟在函数后面则是调用函数。\n圆括号之中，只能放置表达式，如果将语句放在圆括号之中，就会报错。\n(var a = 1)// SyntaxError: Unexpected token var\n\n左结合与右结合对于优先级别相同的运算符，同时出现的时候，就会有计算顺序的问题。\na OP b OP c\n\n上面代码中，OP表示运算符。它可以有两种解释方式。\n// 方式一(a OP b) OP c// 方式二a OP (b OP c)\n\n上面的两种方式，得到的计算结果往往是不一样的。方式一是将左侧两个运算数结合在一起，采用这种解释方式的运算符，称为“左结合”（left-to-right associativity）运算符；方式二是将右侧两个运算数结合在一起，这样的运算符称为“右结合”运算符（right-to-left associativity）。\nJavaScript 语言的大多数运算符是“左结合”，请看下面加法运算符的例子。\nx + y + z// 引擎解释如下(x + y) + z\n\n上面代码中，x与y结合在一起，它们的预算结果再与z进行运算。\n少数运算符是“右结合”，其中最主要的是赋值运算符（=）和三元条件运算符（?:）。\nw = x = y = z;q = a ? b : c ? d : e ? f : g;\n\n上面代码的解释方式如下。\nw = (x = (y = z));q = a ? b : (c ? d : (e ? f : g));\n\n上面的两行代码，都是右侧的运算数结合在一起。\n另外，指数运算符（**）也是右结合。\n2 ** 3 ** 2// 相当于 2 ** (3 ** 2)// 512\n\n未完待续\n","tags":["教程","JavaScript"]},{"title":"从零开始学JavaScript（017 错误处理机制）","url":"/2023/08/23/js017/","content":"JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供Error构造函数，所有抛出的错误都是这个构造函数的实例。\n\n错误处理机制Error 实例对象var err = new Error(&#x27;出错了&#x27;);err.message // &quot;出错了&quot;\n\n上面代码中，我们调用Error()构造函数，生成一个实例对象err。Error()构造函数接受一个参数，表示错误提示，可以从实例的message属性读到这个参数。抛出Error实例对象以后，整个程序就中断在发生错误的地方，不再往下执行。\nJavaScript 语言标准只提到，Error实例对象必须有message属性，表示出错时的提示信息，没有提到其他属性。大多数 JavaScript 引擎，对Error实例还提供name和stack属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。\n\nmessage：错误提示信息\nname：错误名称（非标准属性）\nstack：错误的堆栈（非标准属性）\n\n使用name和message这两个属性，可以对发生什么错误有一个大概的了解。\nif (error.name) &#123;  console.log(error.name + &#x27;: &#x27; + error.message);&#125;\n\nstack属性用来查看错误发生时的堆栈。\nfunction throwit() &#123;  throw new Error(&#x27;&#x27;);&#125;function catchit() &#123;  try &#123;    throwit();  &#125; catch(e) &#123;    console.log(e.stack); // print stack trace  &#125;&#125;catchit()// Error//    at throwit (~/examples/throwcatch.js:9:11)//    at catchit (~/examples/throwcatch.js:3:9)//    at repl:1:5\n\n上面代码中，错误堆栈的最内层是throwit函数，然后是catchit函数，最后是函数的运行环境。\n原生错误类型Error实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在Error的6个派生对象。\nSyntaxError 对象SyntaxError对象是解析代码时发生的语法错误。\n// 变量名错误var 1a;// Uncaught SyntaxError: Invalid or unexpected token// 缺少括号console.log &#x27;hello&#x27;);// Uncaught SyntaxError: Unexpected string\n\n上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出SyntaxError。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”。\nReferenceError 对象ReferenceError对象是引用一个不存在的变量时发生的错误。\n// 使用一个不存在的变量unknownVariable// Uncaught ReferenceError: unknownVariable is not defined\n\n另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果赋值。\n// 等号左侧不是变量console.log() = 1// Uncaught ReferenceError: Invalid left-hand side in assignment\n\n上面代码对函数console.log的运行结果赋值，结果引发了ReferenceError错误。\nRangeError 对象RangeError对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。\n// 数组长度不得为负数new Array(-1)// Uncaught RangeError: Invalid array length\n\nTypeError 对象TypeError对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。\nnew 123// Uncaught TypeError: 123 is not a constructorvar obj = &#123;&#125;;obj.unknownMethod()// Uncaught TypeError: obj.unknownMethod is not a function\n\n上面代码的第二种情况，调用对象不存在的方法，也会抛出TypeError错误，因为obj.unknownMethod的值是undefined，而不是一个函数。\nURIError 对象URIError对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。\ndecodeURI(&#x27;%2&#x27;)// URIError: URI malformed\n\nEvalError 对象eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。\n总结以上这6种派生错误，连同原始的Error对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）。\nvar err1 = new Error(&#x27;出错了！&#x27;);var err2 = new RangeError(&#x27;出错了，变量超出有效范围！&#x27;);var err3 = new TypeError(&#x27;出错了，变量类型无效！&#x27;);err1.message // &quot;出错了！&quot;err2.message // &quot;出错了，变量超出有效范围！&quot;err3.message // &quot;出错了，变量类型无效！&quot;\n\n自定义错误除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。\nfunction UserError(message) &#123;  this.message = message || &#x27;默认信息&#x27;;  this.name = &#x27;UserError&#x27;;&#125;UserError.prototype = new Error();UserError.prototype.constructor = UserError;\n\n上面代码自定义一个错误对象UserError，让它继承Error对象。然后，就可以生成这种自定义类型的错误了。\nnew UserError(&#x27;这是自定义的错误！&#x27;);\n\nthrow 语句throw语句的作用是手动中断程序执行，抛出一个错误。\nvar x = -1;if (x &lt;= 0) &#123;  throw new Error(&#x27;x 必须为正数&#x27;);&#125;// Uncaught Error: x 必须为正数\n\n上面代码中，如果变量x小于等于0，就手动抛出一个错误，告诉用户x的值不正确，整个程序就会在这里中断执行。可以看到，throw抛出的错误就是它的参数，这里是一个Error对象的实例。\nthrow也可以抛出自定义错误。\nfunction UserError(message) &#123;  this.message = message || &#x27;默认信息&#x27;;  this.name = &#x27;UserError&#x27;;&#125;throw new UserError(&#x27;出错了！&#x27;);// Uncaught UserError &#123;message: &quot;出错了！&quot;, name: &quot;UserError&quot;&#125;\n\n上面代码中，throw抛出的是一个UserError实例。\n实际上，throw可以抛出任何类型的值。也就是说，它的参数可以是任何值。\n// 抛出一个字符串throw &#x27;Error！&#x27;;// Uncaught Error！// 抛出一个数值throw 42;// Uncaught 42// 抛出一个布尔值throw true;// Uncaught true// 抛出一个对象throw &#123;  toString: function () &#123;    return &#x27;Error!&#x27;;  &#125;&#125;;// Uncaught &#123;toString: ƒ&#125;\n\n对于 JavaScript 引擎来说，遇到throw语句，程序就中止了。引擎会接收到throw抛出的信息，可能是一个错误实例，也可能是其他类型的值。\ntry…catch 结构一旦发生错误，程序就中止执行了。JavaScript 提供了try...catch结构，允许对错误进行处理，选择是否往下执行。\ntry &#123;  throw new Error(&#x27;出错了!&#x27;);&#125; catch (e) &#123;  console.log(e.name + &quot;: &quot; + e.message);  console.log(e.stack);&#125;// Error: 出错了!//   at &lt;anonymous&gt;:3:9//   ...\n\n上面代码中，try代码块抛出错误（上例用的是throw语句），JavaScript 引擎就立即把代码的执行，转到catch代码块，或者说错误被catch代码块捕获了。catch接受一个参数，表示try代码块抛出的值。\n如果你不确定某些代码是否会报错，就可以把它们放在try...catch代码块之中，便于进一步对错误进行处理。\ntry &#123;  f();&#125; catch(e) &#123;  // 处理错误&#125;\n\n上面代码中，如果函数f执行报错，就会进行catch代码块，接着对错误进行处理。\ncatch代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。\ntry &#123;  throw &quot;出错了&quot;;&#125; catch (e) &#123;  console.log(111);&#125;console.log(222);// 111// 222\n\n上面代码中，try代码块抛出的错误，被catch代码块捕获后，程序会继续向下执行。\ncatch代码块之中，还可以再抛出错误，甚至使用嵌套的try...catch结构。\nvar n = 100;try &#123;  throw n;&#125; catch (e) &#123;  if (e &lt;= 50) &#123;    // ...  &#125; else &#123;    throw e;  &#125;&#125;// Uncaught 100\n\n上面代码中，catch代码之中又抛出了一个错误。\n为了捕捉不同类型的错误，catch代码块之中可以加入判断语句。\ntry &#123;  foo.bar();&#125; catch (e) &#123;  if (e instanceof EvalError) &#123;    console.log(e.name + &quot;: &quot; + e.message);  &#125; else if (e instanceof RangeError) &#123;    console.log(e.name + &quot;: &quot; + e.message);  &#125;  // ...&#125;\n\n上面代码中，catch捕获错误之后，会判断错误类型（EvalError还是RangeError），进行不同的处理。\nfinally 代码块try...catch结构允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句。\nfunction cleansUp() &#123;  try &#123;    throw new Error(&#x27;出错了……&#x27;);    console.log(&#x27;此行不会执行&#x27;);  &#125; finally &#123;    console.log(&#x27;完成清理工作&#x27;);  &#125;&#125;cleansUp()// 完成清理工作// Uncaught Error: 出错了……//    at cleansUp (&lt;anonymous&gt;:3:11)//    at &lt;anonymous&gt;:10:1\n\n上面代码中，由于没有catch语句块，一旦发生错误，代码就会中断执行。中断执行之前，会先执行finally代码块，然后再向用户提示报错信息。\nfunction idle(x) &#123;  try &#123;    console.log(x);    return &#x27;result&#x27;;  &#125; finally &#123;    console.log(&#x27;FINALLY&#x27;);  &#125;&#125;idle(&#x27;hello&#x27;)// hello// FINALLY\n\n上面代码中，try代码块没有发生错误，而且里面还包括return语句，但是finally代码块依然会执行。而且，这个函数的返回值还是result。\n下面的例子说明，return语句的执行是排在finally代码之前，只是等finally代码执行完毕后才返回。\nvar count = 0;function countUp() &#123;  try &#123;    return count;  &#125; finally &#123;    count++;  &#125;&#125;countUp()// 0count// 1\n\n上面代码说明，return语句里面的count的值，是在finally代码块运行之前就获取了。\n下面是finally代码块用法的典型场景。\nopenFile();try &#123;  writeFile(Data);&#125; catch(e) &#123;  handleError(e);&#125; finally &#123;  closeFile();&#125;\n\n上面代码首先打开一个文件，然后在try代码块中写入文件，如果没有发生错误，则运行finally代码块关闭文件；一旦发生错误，则先使用catch代码块处理错误，再使用finally代码块关闭文件。\n下面的例子充分反映了try...catch...finally这三者之间的执行顺序。\nfunction f() &#123;  try &#123;    console.log(0);    throw &#x27;bug&#x27;;  &#125; catch(e) &#123;    console.log(1);    return true; // 这句原本会延迟到 finally 代码块结束再执行    console.log(2); // 不会运行  &#125; finally &#123;    console.log(3);    return false; // 这句会覆盖掉前面那句 return    console.log(4); // 不会运行  &#125;  console.log(5); // 不会运行&#125;var result = f();// 0// 1// 3result// false\n\n上面代码中，catch代码块结束执行之前，会先执行finally代码块。\ncatch代码块之中，触发转入finally代码块的标志，不仅有return语句，还有throw语句。\nfunction f() &#123;  try &#123;    throw &#x27;出错了！&#x27;;  &#125; catch(e) &#123;    console.log(&#x27;捕捉到内部错误&#x27;);    throw e; // 这句原本会等到finally结束再执行  &#125; finally &#123;    return false; // 直接返回  &#125;&#125;try &#123;  f();&#125; catch(e) &#123;  // 此处不会执行  console.log(&#x27;caught outer &quot;bogus&quot;&#x27;);&#125;//  捕捉到内部错误\n\n上面代码中，进入catch代码块之后，一遇到throw语句，就会去执行finally代码块，其中有return false语句，因此就直接返回了，不再会回去执行catch代码块剩下的部分了。\ntry代码块内部，还可以再使用try代码块。\ntry &#123;  try &#123;    consle.log(&#x27;Hello world!&#x27;); // 报错  &#125;  finally &#123;    console.log(&#x27;Finally&#x27;);  &#125;  console.log(&#x27;Will I run?&#x27;);&#125; catch(error) &#123;  console.error(error.message);&#125;// Finally// consle is not defined\n\n上面代码中，try里面还有一个try。内层的try报错（console拼错了），这时会执行内层的finally代码块，然后抛出错误，被外层的catch捕获。\n参考连接\nJani Hartikainen, JavaScript Errors and How to Fix Them\n\n\n未完待续\n","tags":["教程","JavaScript"]},{"title":"从零开始学JavaScript（016 数据类型的转换）","url":"/2023/08/22/js016/","content":"JavaScript 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。\n\n数据类型的转换概述JavaScript 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。\nvar x = y ? 1 : &#x27;a&#x27;;\n\n上面代码中，变量x到底是数值还是字符串，取决于另一个变量y的值。y为true时，x是一个数值；y为false时，x是一个字符串。这意味着，x的类型没法在编译阶段就知道，必须等到运行时才能知道。\n虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的。如果运算符发现，运算子的类型与预期不符，就会自动转换类型。比如，减法运算符预期左右两侧的运算子应该是数值，如果不是，就会自动将它们转为数值。\n&#x27;4&#x27; - &#x27;3&#x27; // 1\n\n上面代码中，虽然是两个字符串相减，但是依然会得到结果数值1，原因就在于 JavaScript 将运算子自动转为了数值。\n本章讲解数据类型自动转换的规则。在此之前，先讲解如何手动强制转换数据类型。\n强制转换强制转换主要指使用Number()、String()和Boolean()三个函数，手动将各种类型的值，分别转换成数字、字符串或者布尔值。\nNumber()使用Number函数，可以将任意类型的值转化成数值。\n下面分成两种情况讨论，一种是参数是原始类型的值，另一种是参数是对象。\n（1）原始类型值\n原始类型值的转换规则如下。\n// 数值：转换后还是原来的值Number(324) // 324// 字符串：如果可以被解析为数值，则转换为相应的数值Number(&#x27;324&#x27;) // 324// 字符串：如果不可以被解析为数值，返回 NaNNumber(&#x27;324abc&#x27;) // NaN// 空字符串转为0Number(&#x27;&#x27;) // 0// 布尔值：true 转成 1，false 转成 0Number(true) // 1Number(false) // 0// undefined：转成 NaNNumber(undefined) // NaN// null：转成0Number(null) // 0\n\nNumber函数将字符串转为数值，要比parseInt函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为NaN。\nparseInt(&#x27;42 cats&#x27;) // 42Number(&#x27;42 cats&#x27;) // NaN\n\n上面代码中，parseInt逐个解析字符，而Number函数整体转换字符串的类型。\n另外，parseInt和Number函数都会自动过滤一个字符串前导和后缀的空格。\nparseInt(&#x27;\\t\\v\\r12.34\\n&#x27;) // 12Number(&#x27;\\t\\v\\r12.34\\n&#x27;) // 12.34\n\n（2）对象\n简单的规则是，Number方法的参数是对象时，将返回NaN，除非是包含单个数值的数组。\nNumber(&#123;a: 1&#125;) // NaNNumber([1, 2, 3]) // NaNNumber([5]) // 5\n\n之所以会这样，是因为Number背后的转换规则比较复杂。\n第一步，调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。\n第二步，如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。如果toString方法返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。\n第三步，如果toString方法返回的是对象，就报错。\n请看下面的例子。\nvar obj = &#123;x: 1&#125;;Number(obj) // NaN// 等同于if (typeof obj.valueOf() === &#x27;object&#x27;) &#123;  Number(obj.toString());&#125; else &#123;  Number(obj.valueOf());&#125;\n\n上面代码中，Number函数将obj对象转为数值。背后发生了一连串的操作，首先调用obj.valueOf方法, 结果返回对象本身；于是，继续调用obj.toString方法，这时返回字符串[object Object]，对这个字符串使用Number函数，得到NaN。\n默认情况下，对象的valueOf方法返回对象本身，所以一般总是会调用toString方法，而toString方法返回对象的类型字符串（比如[object Object]）。所以，会有下面的结果。\nNumber(&#123;&#125;) // NaN\n\n如果toString方法返回的不是原始类型的值，结果就会报错。\nvar obj = &#123;  valueOf: function () &#123;    return &#123;&#125;;  &#125;,  toString: function () &#123;    return &#123;&#125;;  &#125;&#125;;Number(obj)// TypeError: Cannot convert object to primitive value\n\n上面代码的valueOf和toString方法，返回的都是对象，所以转成数值时会报错。\n从上例还可以看到，valueOf和toString方法，都是可以自定义的。\nNumber(&#123;  valueOf: function () &#123;    return 2;  &#125;&#125;)// 2Number(&#123;  toString: function () &#123;    return 3;  &#125;&#125;)// 3Number(&#123;  valueOf: function () &#123;    return 2;  &#125;,  toString: function () &#123;    return 3;  &#125;&#125;)// 2\n\n上面代码对三个对象使用Number函数。第一个对象返回valueOf方法的值，第二个对象返回toString方法的值，第三个对象表示valueOf方法先于toString方法执行。\nString()String函数可以将任意类型的值转化成字符串，转换规则如下。\n（1）原始类型值\n\n数值：转为相应的字符串。\n字符串：转换后还是原来的值。\n布尔值：true转为字符串&quot;true&quot;，false转为字符串&quot;false&quot;。\nundefined：转为字符串&quot;undefined&quot;。\nnull：转为字符串&quot;null&quot;。\n\nString(123) // &quot;123&quot;String(&#x27;abc&#x27;) // &quot;abc&quot;String(true) // &quot;true&quot;String(undefined) // &quot;undefined&quot;String(null) // &quot;null&quot;\n\n（2）对象\nString方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。\nString(&#123;a: 1&#125;) // &quot;[object Object]&quot;String([1, 2, 3]) // &quot;1,2,3&quot;\n\nString方法背后的转换规则，与Number方法基本相同，只是互换了valueOf方法和toString方法的执行顺序。\n\n先调用对象自身的toString方法。如果返回原始类型的值，则对该值使用String函数，不再进行以下步骤。\n\n如果toString方法返回的是对象，再调用原对象的valueOf方法。如果valueOf方法返回原始类型的值，则对该值使用String函数，不再进行以下步骤。\n\n如果valueOf方法返回的是对象，就报错。\n\n\n下面是一个例子。\nString(&#123;a: 1&#125;)// &quot;[object Object]&quot;// 等同于String(&#123;a: 1&#125;.toString())// &quot;[object Object]&quot;\n\n上面代码先调用对象的toString方法，发现返回的是字符串[object Object]，就不再调用valueOf方法了。\n如果toString法和valueOf方法，返回的都是对象，就会报错。\nvar obj = &#123;  valueOf: function () &#123;    return &#123;&#125;;  &#125;,  toString: function () &#123;    return &#123;&#125;;  &#125;&#125;;String(obj)// TypeError: Cannot convert object to primitive value\n\n下面是通过自定义toString方法，改变返回值的例子。\nString(&#123;  toString: function () &#123;    return 3;  &#125;&#125;)// &quot;3&quot;String(&#123;  valueOf: function () &#123;    return 2;  &#125;&#125;)// &quot;[object Object]&quot;String(&#123;  valueOf: function () &#123;    return 2;  &#125;,  toString: function () &#123;    return 3;  &#125;&#125;)// &quot;3&quot;\n\n上面代码对三个对象使用String函数。第一个对象返回toString方法的值（数值3），第二个对象返回的还是toString方法的值（[object Object]），第三个对象表示toString方法先于valueOf方法执行。\nBoolean()Boolean()函数可以将任意类型的值转为布尔值。\n它的转换规则相对简单：除了以下五个值的转换结果为false，其他的值全部为true。\n\nundefined\nnull\n0（包含-0和+0）\nNaN\n&#39;&#39;（空字符串）\n\nBoolean(undefined) // falseBoolean(null) // falseBoolean(0) // falseBoolean(NaN) // falseBoolean(&#x27;&#x27;) // false\n\n当然，true和false这两个布尔值不会发生变化。\nBoolean(true) // trueBoolean(false) // false\n\n注意，所有对象（包括空对象）的转换结果都是true，甚至连false对应的布尔对象new Boolean(false)也是true（详见《原始类型值的包装对象》一章）。\nBoolean(&#123;&#125;) // trueBoolean([]) // trueBoolean(new Boolean(false)) // true\n\n所有对象的布尔值都是true，这是因为 JavaScript 语言设计的时候，出于性能的考虑，如果对象需要计算才能得到布尔值，对于obj1 &amp;&amp; obj2这样的场景，可能会需要较多的计算。为了保证性能，就统一规定，对象的布尔值为true。\n自动转换下面介绍自动转换，它是以强制转换为基础的。\n遇到以下三种情况时，JavaScript 会自动转换数据类型，即转换是自动完成的，用户不可见。\n第一种情况，不同类型的数据互相运算。\n123 + &#x27;abc&#x27; // &quot;123abc&quot;\n\n第二种情况，对非布尔值类型的数据求布尔值。\nif (&#x27;abc&#x27;) &#123;  console.log(&#x27;hello&#x27;)&#125;  // &quot;hello&quot;\n\n第三种情况，对非数值类型的值使用一元运算符（即+和-）。\n+ &#123;foo: &#x27;bar&#x27;&#125; // NaN- [1, 2, 3] // NaN\n\n自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用String()函数进行转换。如果该位置既可以是字符串，也可能是数值，那么默认转为数值。\n由于自动转换具有不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用Boolean()、Number()和String()函数进行显式转换。\n自动转换为布尔值JavaScript 遇到预期为布尔值的地方（比如if语句的条件部分），就会将非布尔值的参数自动转换为布尔值。系统内部会自动调用Boolean()函数。\n因此除了以下五个值，其他都是自动转为true。\n\nundefined\nnull\n+0或-0\nNaN\n&#39;&#39;（空字符串）\n\n下面这个例子中，条件部分的每个值都相当于false，使用否定运算符后，就变成了true。\nif ( !undefined  &amp;&amp; !null  &amp;&amp; !0  &amp;&amp; !NaN  &amp;&amp; !&#x27;&#x27;) &#123;  console.log(&#x27;true&#x27;);&#125; // true\n\n下面两种写法，有时也用于将一个表达式转为布尔值。它们内部调用的也是Boolean()函数。\n// 写法一expression ? true : false// 写法二!! expression\n\n自动转换为字符串JavaScript 遇到预期为字符串的地方，就会将非字符串的值自动转为字符串。具体规则是，先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串。\n字符串的自动转换，主要发生在字符串的加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串。\n&#x27;5&#x27; + 1 // &#x27;51&#x27;&#x27;5&#x27; + true // &quot;5true&quot;&#x27;5&#x27; + false // &quot;5false&quot;&#x27;5&#x27; + &#123;&#125; // &quot;5[object Object]&quot;&#x27;5&#x27; + [] // &quot;5&quot;&#x27;5&#x27; + function ()&#123;&#125; // &quot;5function ()&#123;&#125;&quot;&#x27;5&#x27; + undefined // &quot;5undefined&quot;&#x27;5&#x27; + null // &quot;5null&quot;\n\n这种自动转换很容易出错。\nvar obj = &#123;  width: &#x27;100&#x27;&#125;;obj.width + 20 // &quot;10020&quot;\n\n上面代码中，开发者可能期望返回120，但是由于自动转换，实际上返回了一个字符10020。\n自动转换为数值JavaScript 遇到预期为数值的地方，就会将参数值自动转换为数值。系统内部会自动调用Number()函数。\n除了加法运算符（+）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。\n&#x27;5&#x27; - &#x27;2&#x27; // 3&#x27;5&#x27; * &#x27;2&#x27; // 10true - 1  // 0false - 1 // -1&#x27;1&#x27; - 1   // 0&#x27;5&#x27; * []    // 0false / &#x27;5&#x27; // 0&#x27;abc&#x27; - 1   // NaNnull + 1 // 1undefined + 1 // NaN\n\n上面代码中，运算符两侧的运算子，都被转成了数值。\n\n注意：null转为数值时为0，而undefined转为数值时为NaN。\n\n一元运算符也会把运算子转成数值。\n+&#x27;abc&#x27; // NaN-&#x27;abc&#x27; // NaN+true // 1-false // 0\n\n参考链接\nAxel Rauschmayer, What is {} + {} in JavaScript?\nAxel Rauschmayer, JavaScript quirk 1: implicit conversion of values\nBenjie Gillam, Quantum JavaScript?\n\n\n未完待续\n","tags":["教程","JavaScript"]},{"title":"从零开始学JavaScript（018 编程风格）","url":"/2023/08/24/js018/","content":"“编程风格”（programming style）指的是编写代码的样式规则。不同的程序员，往往有不同的编程风格。\n\n编程风格概述有人说，编译器的规范叫做“语法规则”（grammar），这是程序员必须遵守的；而编译器忽略的部分，就叫“编程风格”（programming style），这是程序员可以自由选择的。这种说法不完全正确，程序员固然可以自由选择编程风格，但是好的编程风格有助于写出质量更高、错误更少、更易于维护的程序。\n所以，编程风格的选择不应该基于个人爱好、熟悉程度、打字量等因素，而要考虑如何尽量使代码清晰易读、减少出错。你选择的，不是你喜欢的风格，而是一种能够清晰表达你的意图的风格。这一点，对于 JavaScript 这种语法自由度很高的语言尤其重要。\n必须牢记的一点是，如果你选定了一种“编程风格”，就应该坚持遵守，切忌多种风格混用。如果你加入他人的项目，就应该遵守现有的风格。\n缩进行首的空格和 Tab 键，都可以产生代码缩进效果（indent）。\nTab 键可以节省击键次数，但不同的文本编辑器对 Tab 的显示不尽相同，有的显示四个空格，有的显示两个空格，所以有人觉得，空格键可以使得显示效果更统一。\n无论你选择哪一种方法，都是可以接受的，要做的就是始终坚持这一种选择。不要一会使用 Tab 键，一会使用空格键。\n区块如果循环和判断的代码体只有一行，JavaScript 允许该区块（block）省略大括号。\nif (a)  b();  c();\n\n上面代码的原意可能是下面这样。\nif (a) &#123;  b();  c();&#125;\n\n但是，实际效果却是下面这样。\nif (a) &#123;  b();&#125;  c();\n\n因此，建议总是使用大括号表示区块。\n另外，区块起首的大括号的位置，有许多不同的写法。最流行的有两种，一种是起首的大括号另起一行。\nblock&#123;  // ...&#125;\n\n另一种是起首的大括号跟在关键字的后面。\nblock &#123;  // ...&#125;\n\n一般来说，这两种写法都可以接受。但是，JavaScript 要使用后一种，因为 JavaScript 会自动添加句末的分号，导致一些难以察觉的错误。\nreturn&#123;  key: value&#125;;// 相当于return;&#123;  key: value&#125;;\n\n上面的代码的原意，是要返回一个对象，但实际上返回的是undefined，因为 JavaScript 自动在return语句后面添加了分号。为了避免这一类错误，需要写成下面这样。\nreturn &#123;  key : value&#125;;\n\n因此，表示区块起首的大括号，不要另起一行。\n圆括号圆括号（parentheses）在 JavaScript 中有两种作用，一种表示函数的调用，另一种表示表达式的组合（grouping）。\n// 圆括号表示函数的调用console.log(&#x27;abc&#x27;);// 圆括号表示表达式的组合(1 + 2) * 3\n\n建议可以用空格，区分这两种不同的括号。\n\n\n表示函数调用时，函数名与左括号之间没有空格。\n\n表示函数定义时，函数名与左括号之间没有空格。\n\n其他情况时，前面位置的语法元素与左括号之间，都有一个空格。\n\n\n\n按照上面的规则，下面的写法都是不规范的。\nfoo (bar)return(a+b);if(a === 0) &#123;...&#125;function foo (b) &#123;...&#125;function(x) &#123;...&#125;\n\n上面代码的最后一行是一个匿名函数，function是语法关键字，不是函数名，所以与左括号之间应该要有一个空格。\n行尾的分号分号表示一条语句的结束。JavaScript 允许省略行尾的分号。事实上，确实有一些开发者行尾从来不写分号。但是，由于下面要讨论的原因，建议还是不要省略这个分号。\n不使用分号的情况首先，以下三种情况，语法规定本来就不需要在结尾添加分号。\n（1）for 和 while 循环\nfor ( ; ; ) &#123;&#125; // 没有分号while (true) &#123;&#125; // 没有分号\n\n注意，do...while循环是有分号的。\ndo &#123;  a--;&#125; while(a &gt; 0); // 分号不能省略\n\n（2）分支语句：if，switch，try\nif (true) &#123;&#125; // 没有分号switch () &#123;&#125; // 没有分号try &#123;&#125; catch &#123;&#125; // 没有分号\n\n（3）函数的声明语句\nfunction f() &#123;&#125; // 没有分号\n\n注意，函数表达式仍然要使用分号。\nvar f = function f() &#123;&#125;;\n\n以上三种情况，如果使用了分号，并不会出错。因为，解释引擎会把这个分号解释为空语句。\n分号的自动添加除了上一节的三种情况，所有语句都应该使用分号。但是，如果没有使用分号，大多数情况下，JavaScript 会自动添加。\nvar a = 1// 等同于var a = 1;\n\n这种语法特性被称为“分号的自动添加”（Automatic Semicolon Insertion，简称 ASI）。\n因此，有人提倡省略句尾的分号。麻烦的是，如果下一行的开始可以与本行的结尾连在一起解释，JavaScript 就不会自动添加分号。\n// 等同于 var a = 3vara=3// 等同于 &#x27;abc&#x27;.length&#x27;abc&#x27;.length// 等同于 return a + b;return a +b;// 等同于 obj.foo(arg1, arg2);obj.foo(arg1,arg2);// 等同于 3 * 2 + 10 * (27 / 6)3 * 2+10 * (27 / 6)\n\n上面代码都会多行放在一起解释，不会每一行自动添加分号。这些例子还是比较容易看出来的，但是下面这个例子就不那么容易看出来了。\nx = y(function () &#123;  // ...&#125;)();// 等同于x = y(function () &#123;...&#125;)();\n\n下面是更多不会自动添加分号的例子。\n// 引擎解释为 c(d+e)var a = b + c(d+e).toString();// 引擎解释为 a = b/hi/g.exec(c).map(d)// 正则表达式的斜杠，会当作除法运算符a = b/hi/g.exec(c).map(d);// 解释为&#x27;b&#x27;[&#x27;red&#x27;, &#x27;green&#x27;]，// 即把字符串当作一个数组，按索引取值var a = &#x27;b&#x27;[&#x27;red&#x27;, &#x27;green&#x27;].forEach(function (c) &#123;  console.log(c);&#125;)// 解释为 function (x) &#123; return x &#125;(a++)// 即调用匿名函数，结果f等于0var a = 0;var f = function (x) &#123; return x &#125;(a++)\n\n只有下一行的开始与本行的结尾，无法放在一起解释，JavaScript 引擎才会自动添加分号。\nif (a &lt; 0) a = 0console.log(a)// 等同于下面的代码，// 因为 0console 没有意义if (a &lt; 0) a = 0;console.log(a)\n\n另外，如果一行的起首是“自增”（++）或“自减”（--）运算符，则它们的前面会自动添加分号。\na = b = c = 1a++b--cconsole.log(a, b, c)// 1 2 0\n\n上面代码之所以会得到1 2 0的结果，原因是自增和自减运算符前，自动加上了分号。上面的代码实际上等同于下面的形式。\na = b = c = 1;a;++b;--c;\n\n如果continue、break、return和throw这四个语句后面，直接跟换行符，则会自动添加分号。这意味着，如果return语句返回的是一个对象的字面量，起首的大括号一定要写在同一行，否则得不到预期结果。\nreturn&#123; first: &#x27;Jane&#x27; &#125;;// 解释成return;&#123; first: &#x27;Jane&#x27; &#125;;\n\n由于解释引擎自动添加分号的行为难以预测，因此编写代码的时候不应该省略行尾的分号。\n不应该省略结尾的分号，还有一个原因。有些 JavaScript 代码压缩器（uglifier）不会自动添加分号，因此遇到没有分号的结尾，就会让代码保持原状，而不是压缩成一行，使得压缩无法得到最优的结果。\n另外，不写结尾的分号，可能会导致脚本合并出错。所以，有的代码库在第一行语句开始前，会加上一个分号。\n;var a = 1;// ...\n\n上面这种写法就可以避免与其他脚本合并时，排在前面的脚本最后一行语句没有分号，导致运行出错的问题。\n全局变量JavaScript 最大的语法缺点，可能就是全局变量对于任何一个代码块，都是可读可写。这对代码的模块化和重复使用，非常不利。\n因此，建议避免使用全局变量。如果不得不使用，可以考虑用大写字母表示变量名，这样更容易看出这是全局变量，比如UPPER_CASE。\n变量声明JavaScript 会自动将变量声明“提升”（hoist）到代码块（block）的头部。\nif (!x) &#123;  var x = &#123;&#125;;&#125;// 等同于var x;if (!x) &#123;  x = &#123;&#125;;&#125;\n\n这意味着，变量x是if代码块之前就存在了。为了避免可能出现的问题，最好把变量声明都放在代码块的头部。\nfor (var i = 0; i &lt; 10; i++) &#123;  // ...&#125;// 写成var i;for (i = 0; i &lt; 10; i++) &#123;  // ...&#125;\n\n上面这样的写法，就容易看出存在一个全局的循环变量i。\n另外，所有函数都应该在使用之前定义。函数内部的变量声明，都应该放在函数的头部。\nwith 语句with可以减少代码的书写，但是会造成混淆。\nwith (o) &#123;　foo = bar;&#125;\n\n上面的代码，可以有四种运行结果：\no.foo = bar;o.foo = o.bar;foo = bar;foo = o.bar;\n\n这四种结果都可能发生，取决于不同的变量是否有定义。因此，不要使用with语句。\n相等和严格相等JavaScript 有两个表示相等的运算符：“相等”（==）和“严格相等”（===）。\n相等运算符会自动转换变量类型，造成很多意想不到的情况。\n0 == &#x27;&#x27;// true1 == true // true2 == true // false0 == &#x27;0&#x27; // truefalse == &#x27;false&#x27; // falsefalse == &#x27;0&#x27; // true&#x27; \\t\\r\\n &#x27; == 0 // true\n\n因此，建议不要使用相等运算符（==），只使用严格相等运算符（===）。\n语句的合并有些程序员追求简洁，喜欢合并不同目的的语句。比如，原来的语句是\na = b;if (a) &#123;  // ...&#125;\n\n他喜欢写成下面这样。\nif (a = b) &#123;  // ...&#125;\n\n虽然语句少了一行，但是可读性大打折扣，而且会造成误读，让别人误解这行代码的意思是下面这样。\nif （a === b）&#123;  // ...&#125;\n\n建议不要将不同目的的语句，合并成一行。\n自增和自减运算符自增（++）和自减（--）运算符，放在变量的前面或后面，返回的值不一样，很容易发生错误。事实上，所有的++运算符都可以用+= 1代替。\n++x// 等同于x += 1;\n\n改用+= 1，代码变得更清晰了。\n建议自增（++）和自减（--）运算符尽量使用+=和-=代替。\nswitch…case 结构switch...case结构要求，在每一个case的最后一行必须是break语句，否则会接着运行下一个case。这样不仅容易忘记，还会造成代码的冗长。\n而且，switch...case不使用大括号，不利于代码形式的统一。此外，这种结构类似于goto语句，容易造成程序流程的混乱，使得代码结构混乱不堪，不符合面向对象编程的原则。\nfunction doAction(action) &#123;  switch (action) &#123;    case &#x27;hack&#x27;:      return &#x27;hack&#x27;;    case &#x27;slash&#x27;:      return &#x27;slash&#x27;;    case &#x27;run&#x27;:      return &#x27;run&#x27;;    default:      throw new Error(&#x27;Invalid action.&#x27;);  &#125;&#125;\n\n上面的代码建议改写成对象结构。\nfunction doAction(action) &#123;  var actions = &#123;    &#x27;hack&#x27;: function () &#123;      return &#x27;hack&#x27;;    &#125;,    &#x27;slash&#x27;: function () &#123;      return &#x27;slash&#x27;;    &#125;,    &#x27;run&#x27;: function () &#123;      return &#x27;run&#x27;;    &#125;  &#125;;  if (typeof actions[action] !== &#x27;function&#x27;) &#123;    throw new Error(&#x27;Invalid action.&#x27;);  &#125;  return actions[action]();&#125;\n\n因此，建议switch...case结构可以用对象结构代替。\n参考链接\nEric Elliott, Programming JavaScript Applications, Chapter 2. JavaScript Style Guide, O’Reilly, 2014\nAxel Rauschmayer, A meta style guide for JavaScript\nAxel Rauschmayer, Automatic semicolon insertion in JavaScript\nRod Vagg, JavaScript and Semicolons\n\n\n未完待续\n","tags":["教程","JavaScript"]},{"title":"从零开始学JavaScript（019 console 对象与控制台）","url":"/2023/08/24/js019/","content":"“编程风格”（programming style）指的是编写代码的样式规则。不同的程序员，往往有不同的编程风格。\n\nconsole 对象与控制台console 对象console对象是 JavaScript 的原生对象，它有点像 Unix 系统的标准输出stdout和标准错误stderr，可以输出各种信息到控制台，并且还提供了很多有用的辅助方法。\nconsole的常见用途有两个。\n\n调试程序，显示网页代码运行时的错误信息。\n提供了一个命令行接口，用来与网页代码互动。\n\nconsole对象的浏览器实现，包含在浏览器自带的开发工具之中。以 Chrome 浏览器的“开发者工具”（Developer Tools）为例，可以使用下面三种方法的打开它。\n\n按 F12 或者Control + Shift + i（PC）&#x2F; Command + Option + i（Mac）。\n浏览器菜单选择“工具&#x2F;开发者工具”。\n在一个页面元素上，打开右键菜单，选择其中的“Inspect Element”。\n\n打开开发者工具以后，顶端有多个面板。\n\nElements：查看网页的 HTML 源码和 CSS 代码。\nResources：查看网页加载的各种资源文件（比如代码文件、字体文件 CSS 文件等），以及在硬盘上创建的各种内容（比如本地缓存、Cookie、Local Storage等）。\nNetwork：查看网页的 HTTP 通信情况。\nSources：查看网页加载的脚本源码。\nTimeline：查看各种网页行为随时间变化的情况。\nPerformance：查看网页的性能情况，比如 CPU 和内存消耗。\nConsole：用来运行 JavaScript 命令。\n\n这些面板都有各自的用途，以下只介绍Console面板（又称为控制台）。\nConsole面板基本上就是一个命令行窗口，你可以在提示符下，键入各种命令。\nconsole 对象的静态方法console对象提供的各种静态方法，用来与控制台窗口互动。\nconsole.log()，console.info()，console.debug()console.log方法用于在控制台输出信息。它可以接受一个或多个参数，将它们连接起来输出。\nconsole.log(&#x27;Hello World&#x27;)// Hello Worldconsole.log(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)// a b c\n\nconsole.log方法会自动在每次输出的结尾，添加换行符。\nconsole.log(1);console.log(2);console.log(3);// 1// 2// 3\n\n如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。\nconsole.log(&#x27; %s + %s = %s&#x27;, 1, 1, 2)//  1 + 1 = 2\n\n上面代码中，console.log方法的第一个参数有三个占位符（%s），第二、三、四个参数会在显示时，依次替换掉这个三个占位符。\nconsole.log方法支持以下占位符，不同类型的数据必须使用对应的占位符。\n\n%s 字符串\n%d 整数\n%i 整数\n%f 浮点数\n%o 对象的链接\n%c CSS 格式字符串\n\nvar number = 11 * 9;var color = &#x27;red&#x27;;console.log(&#x27;%d %s balloons&#x27;, number, color);// 99 red balloons\n\n上面代码中，第二个参数是数值，对应的占位符是%d，第三个参数是字符串，对应的占位符是%s。\n使用%c占位符时，对应的参数必须是 CSS 代码，用来对输出内容进行 CSS 渲染。\nconsole.log(  &#x27;%cThis text is styled!&#x27;,  &#x27;color: red; background: yellow; font-size: 24px;&#x27;)\n\n上面代码运行后，输出的内容将显示为黄底红字。\nconsole.log方法的两种参数格式，可以结合在一起使用。\nconsole.log(&#x27; %s + %s &#x27;, 1, 1, &#x27;= 2&#x27;)// 1 + 1  = 2\n\n如果参数是一个对象，console.log会显示该对象的值。\nconsole.log(&#123;foo: &#x27;bar&#x27;&#125;)// Object &#123;foo: &quot;bar&quot;&#125;console.log(Date)// function Date() &#123; [native code] &#125;\n\n上面代码输出Date对象的值，结果为一个构造函数。\nconsole.info是console.log方法的别名，用法完全一样。只不过console.info方法会在输出信息的前面，加上一个蓝色图标。\nconsole.debug方法与console.log方法类似，会在控制台输出调试信息。但是，默认情况下，console.debug输出的信息不会显示，只有在打开显示级别在verbose的情况下，才会显示。\nconsole对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义console.log方法。\n[&#x27;log&#x27;, &#x27;info&#x27;, &#x27;warn&#x27;, &#x27;error&#x27;].forEach(function(method) &#123;  console[method] = console[method].bind(    console,    new Date().toISOString()  );&#125;);console.log(&quot;出错了！&quot;);// 2014-05-18T09:00.000Z 出错了！\n\n上面代码表示，使用自定义的console.log方法，可以在显示结果添加当前时间。\nconsole.warn()，console.error()warn方法和error方法也是在控制台输出信息，它们与log方法的不同之处在于，warn方法输出信息时，在最前面加一个黄色三角，表示警告；error方法输出信息时，在最前面加一个红色的叉，表示出错。同时，还会高亮显示输出文字和错误发生的堆栈。其他方面都一样。\nconsole.error(&#x27;Error: %s (%i)&#x27;, &#x27;Server is not responding&#x27;, 500)// Error: Server is not responding (500)console.warn(&#x27;Warning! Too few nodes (%d)&#x27;, document.childNodes.length)// Warning! Too few nodes (1)\n\n可以这样理解，log方法是写入标准输出（stdout），warn方法和error方法是写入标准错误（stderr）。\nconsole.table()对于某些复合类型的数据，console.table方法可以将其转为表格显示。\nvar languages = [  &#123; name: &quot;JavaScript&quot;, fileExtension: &quot;.js&quot; &#125;,  &#123; name: &quot;TypeScript&quot;, fileExtension: &quot;.ts&quot; &#125;,  &#123; name: &quot;CoffeeScript&quot;, fileExtension: &quot;.coffee&quot; &#125;];console.table(languages);\n\n上面代码的language变量，转为表格显示如下。\n\n\n\n(index)\nname\nfileExtension\n\n\n\n0\n“JavaScript”\n“.js”\n\n\n1\n“TypeScript”\n“.ts”\n\n\n2\n“CoffeeScript”\n“.coffee”\n\n\n下面是显示表格内容的例子。\nvar languages = &#123;  csharp: &#123; name: &quot;C#&quot;, paradigm: &quot;object-oriented&quot; &#125;,  fsharp: &#123; name: &quot;F#&quot;, paradigm: &quot;functional&quot; &#125;&#125;;console.table(languages);\n\n上面代码的language，转为表格显示如下。\n\n\n\n(index)\nname\nparadigm\n\n\n\ncsharp\n“C#”\n“object-oriented”\n\n\nfsharp\n“F#”\n“functional”\n\n\nconsole.count()count方法用于计数，输出它被调用了多少次。\nfunction greet(user) &#123;  console.count();  return &#x27;hi &#x27; + user;&#125;greet(&#x27;bob&#x27;)//  : 1// &quot;hi bob&quot;greet(&#x27;alice&#x27;)//  : 2// &quot;hi alice&quot;greet(&#x27;bob&#x27;)//  : 3// &quot;hi bob&quot;\n\n上面代码每次调用greet函数，内部的console.count方法就输出执行次数。\n该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类。\nfunction greet(user) &#123;  console.count(user);  return &quot;hi &quot; + user;&#125;greet(&#x27;bob&#x27;)// bob: 1// &quot;hi bob&quot;greet(&#x27;alice&#x27;)// alice: 1// &quot;hi alice&quot;greet(&#x27;bob&#x27;)// bob: 2// &quot;hi bob&quot;\n\n上面代码根据参数的不同，显示bob执行了两次，alice执行了一次。\nconsole.dir()，console.dirxml()dir方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。\nconsole.log(&#123;f1: &#x27;foo&#x27;, f2: &#x27;bar&#x27;&#125;)// Object &#123;f1: &quot;foo&quot;, f2: &quot;bar&quot;&#125;console.dir(&#123;f1: &#x27;foo&#x27;, f2: &#x27;bar&#x27;&#125;)// Object//   f1: &quot;foo&quot;//   f2: &quot;bar&quot;//   __proto__: Object\n\n上面代码显示dir方法的输出结果，比log方法更易读，信息也更丰富。\n该方法对于输出 DOM 对象非常有用，因为会显示 DOM 对象的所有属性。\nconsole.dir(document.body)\n\nNode 环境之中，还可以指定以代码高亮的形式输出。\nconsole.dir(obj, &#123;colors: true&#125;)\n\ndirxml方法主要用于以目录树的形式，显示 DOM 节点。\nconsole.dirxml(document.body)\n\n如果参数不是 DOM 节点，而是普通的 JavaScript 对象，console.dirxml等同于console.dir。\nconsole.dirxml([1, 2, 3])// 等同于console.dir([1, 2, 3])\n\nconsole.assert()console.assert方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。\n它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。\nconsole.assert(false, &#x27;判断条件不成立&#x27;)// Assertion failed: 判断条件不成立// 相当于try &#123;  if (!false) &#123;    throw new Error(&#x27;判断条件不成立&#x27;);  &#125;&#125; catch(e) &#123;  console.error(e);&#125;\n\n下面是一个例子，判断子节点的个数是否大于等于500。\nconsole.assert(list.childNodes.length &lt; 500, &#x27;节点个数大于等于500&#x27;)\n\n上面代码中，如果符合条件的节点小于500个，不会有任何输出；只有大于等于500时，才会在控制台提示错误，并且显示指定文本。\nconsole.time()，console.timeEnd()这两个方法用于计时，可以算出一个操作所花费的准确时间。\nconsole.time(&#x27;Array initialize&#x27;);var array= new Array(1000000);for (var i = array.length - 1; i &gt;= 0; i--) &#123;  array[i] = new Object();&#125;;console.timeEnd(&#x27;Array initialize&#x27;);// Array initialize: 1914.481ms\n\ntime方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，控制台会显示“计时器名称: 所耗费的时间”。\nconsole.group()，console.groupEnd()，console.groupCollapsed()console.group和console.groupEnd这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠&#x2F;展开。\nconsole.group(&#x27;一级分组&#x27;);console.log(&#x27;一级分组的内容&#x27;);console.group(&#x27;二级分组&#x27;);console.log(&#x27;二级分组的内容&#x27;);console.groupEnd(); // 二级分组结束console.groupEnd(); // 一级分组结束\n\n上面代码会将“二级分组”显示在“一级分组”内部，并且“一级分组”和“二级分组”前面都有一个折叠符号，可以用来折叠本级的内容。\nconsole.groupCollapsed方法与console.group方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。\nconsole.groupCollapsed(&#x27;Fetching Data&#x27;);console.log(&#x27;Request Sent&#x27;);console.error(&#x27;Error: Server not responding (500)&#x27;);console.groupEnd();\n\n上面代码只显示一行”Fetching Data“，点击后才会展开，显示其中包含的两行。\nconsole.trace()，console.clear()console.trace方法显示当前执行的代码在堆栈中的调用路径。\nconsole.trace()// console.trace()//   (anonymous function)//   InjectedScript._evaluateOn//   InjectedScript._evaluateAndWrap//   InjectedScript.evaluate\n\nconsole.clear方法用于清除当前控制台的所有输出，将光标回置到第一行。如果用户选中了控制台的“Preserve log”选项，console.clear方法将不起作用。\n控制台命令行 API浏览器控制台中，除了使用console对象，还可以使用一些控制台自带的命令行方法。\n（1）$_\n$_属性返回上一个表达式的值。\n2 + 2// 4$_// 4\n\n（2）$0 - $4\n控制台保存了最近5个在 Elements 面板选中的 DOM 元素，$0代表倒数第一个（最近一个），$1代表倒数第二个，以此类推直到$4。\n（3）$(selector)\n$(selector)返回第一个匹配的元素，等同于document.querySelector()。注意，如果页面脚本对$有定义，则会覆盖原始的定义。比如，页面里面有 jQuery，控制台执行$(selector)就会采用 jQuery 的实现，返回一个数组。\n（4）$$(selector)\n$$(selector)返回选中的 DOM 对象，等同于document.querySelectorAll。\n（5）$x(path)\n$x(path)方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素。\n$x(&quot;//p[a]&quot;)\n\n上面代码返回所有包含a元素的p元素。\n（6）inspect(object)\ninspect(object)方法打开相关面板，并选中相应的元素，显示它的细节。DOM 元素在Elements面板中显示，比如inspect(document)会在 Elements 面板显示document元素。JavaScript 对象在控制台面板Profiles面板中显示，比如inspect(window)。\n（7）getEventListeners(object)\ngetEventListeners(object)方法返回一个对象，该对象的成员为object登记了回调函数的各种事件（比如click或keydown），每个事件对应一个数组，数组的成员为该事件的回调函数。\n（8）keys(object)，values(object)\nkeys(object)方法返回一个数组，包含object的所有键名。\nvalues(object)方法返回一个数组，包含object的所有键值。\nvar o = &#123;&#x27;p1&#x27;: &#x27;a&#x27;, &#x27;p2&#x27;: &#x27;b&#x27;&#125;;keys(o)// [&quot;p1&quot;, &quot;p2&quot;]values(o)// [&quot;a&quot;, &quot;b&quot;]\n\n（9）monitorEvents(object[, events]) ，unmonitorEvents(object[, events])\nmonitorEvents(object[, events])方法监听特定对象上发生的特定事件。事件发生时，会返回一个Event对象，包含该事件的相关信息。unmonitorEvents方法用于停止监听。\nmonitorEvents(window, &quot;resize&quot;);monitorEvents(window, [&quot;resize&quot;, &quot;scroll&quot;])\n\n上面代码分别表示单个事件和多个事件的监听方法。\nmonitorEvents($0, &#x27;mouse&#x27;);unmonitorEvents($0, &#x27;mousemove&#x27;);\n\n上面代码表示如何停止监听。\nmonitorEvents允许监听同一大类的事件。所有事件可以分成四个大类。\n\nmouse：”mousedown”, “mouseup”, “click”, “dblclick”, “mousemove”, “mouseover”, “mouseout”, “mousewheel”\nkey：”keydown”, “keyup”, “keypress”, “textInput”\ntouch：”touchstart”, “touchmove”, “touchend”, “touchcancel”\ncontrol：”resize”, “scroll”, “zoom”, “focus”, “blur”, “select”, “change”, “submit”, “reset”\n\nmonitorEvents($(&quot;#msg&quot;), &quot;key&quot;);\n\n上面代码表示监听所有key大类的事件。\n（10）其他方法\n命令行 API 还提供以下方法。\n\nclear()：清除控制台的历史。\ncopy(object)：复制特定 DOM 元素到剪贴板。\ndir(object)：显示特定对象的所有属性，是console.dir方法的别名。\ndirxml(object)：显示特定对象的 XML 形式，是console.dirxml方法的别名。\n\ndebugger 语句debugger语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到debugger语句时会自动停下。如果没有除错工具，debugger语句不会产生任何结果，JavaScript 引擎自动跳过这一句。\nChrome 浏览器中，当代码运行到debugger语句时，就会暂停运行，自动打开脚本源码界面。\nfor(var i = 0; i &lt; 5; i++)&#123;  console.log(i);  if (i === 2) debugger;&#125;\n\n上面代码打印出0，1，2以后，就会暂停，自动打开源码界面，等待进一步处理。\n参考链接\nChrome Developer Tools, Using the Console\nMatt West, Mastering The Developer Tools Console\nFirebug Wiki, Console API\nAxel Rauschmayer, The JavaScript console API\nMarius Schulz, Advanced JavaScript Debugging with console.table()\nGoogle Developer, Command Line API Reference\n\n\n未完待续\n","tags":["教程","JavaScript"]},{"title":"如果末世到来了，你需要准备什么？","url":"/2023/08/15/moshi/","content":"在极端情况下，必须做好充足的准备。这不是演习，重复一遍，这不是演习……\n\n食物和水源：富含营养的罐头食品，如蔬菜、水果、鱼、肉类等。耐久性高的干粮，如大米、面粉、谷物等。蜂蜜、果酱等长期保存的食品。储备足够的清洁水和水处理工具，如过滤器或净化片。\n医疗用品和药物：基本的急救工具和药品，如创口贴、消毒液、止痛药、感冒药等。慢性病药物的足够储备，以及处方药的备份处方。医疗用品，如绷带、消毒棉、医用手套等。\n生存装备和工具：照明工具，如手电筒、蜡烛、火柴等。多功能工具，如瑞士军刀。帐篷、睡袋和保暖衣物，以应对恶劣天气。火种工具，如火石或火绳。\n个人卫生和清洁用品：卫生纸、湿纸巾等卫生用品。肥皂、洗发水、牙膏等个人清洁用品。垃圾袋，以便垃圾处理。\n通讯和能源：手持无线电、电池或充电设备，以便与其他人保持联系。太阳能充电器或手摇充电器，以维持电力供应。\n种子和农业工具（适用于长期情况）：蔬菜、水果等可种植作物的种子。农业工具，如锄头、割草机等。\n防御和安全：安全装备，如防护眼镜、口罩、手套等，以应对危险环境。可自卫的工具，如防身武器或防卫工具。\n社交和心理支持：阅读材料、纸牌、棋盘游戏等娱乐活动，以缓解压力和保持心理健康。与家人和社区保持联系的方法，以建立社会支持网络。\n\n末世之下，肯定会发生很多有趣的故事，如果将这些故事串成一部小说，相信会更有意思。\n当然，这也正是我接下来准备做的。\n","tags":["末世"]},{"title":"从零开始学JavaScript（020 Object 对象）","url":"/2023/08/28/js020/","content":"JavaScript 原生提供Object对象（注意起首的O是大写），本章介绍该对象原生的各种方法。\n\nObject 对象概述JavaScript 的所有其他对象都继承自Object对象，即那些对象都是Object的实例。\nObject对象的原生方法分成两类：Object本身的方法与Object的实例方法。\n（1）Object对象本身的方法\n所谓“本身的方法”就是直接定义在Object对象的方法。\nObject.print = function (o) &#123; console.log(o) &#125;;\n\n上面代码中，print方法就是直接定义在Object对象上。\n（2）Object的实例方法\n所谓实例方法就是定义在Object原型对象Object.prototype上的方法。它可以被Object实例直接使用。\nObject.prototype.print = function () &#123;  console.log(this);&#125;;var obj = new Object();obj.print() // Object\n\n上面代码中，Object.prototype定义了一个print方法，然后生成一个Object的实例obj。obj直接继承了Object.prototype的属性和方法，可以直接使用obj.print调用print方法。也就是说，obj对象的print方法实质上就是调用Object.prototype.print方法。\n关于原型对象object.prototype的详细解释，参见《面向对象编程》章节。这里只要知道，凡是定义在Object.prototype对象上面的属性和方法，将被所有实例对象共享就可以了。\n以下先介绍Object作为函数的用法，然后再介绍Object对象的原生方法，分成对象自身的方法（又称为“静态方法”）和实例方法两部分。\nObject()Object本身是一个函数，可以当作工具方法使用，将任意值转为对象。这个方法常用于保证某个值一定是对象。\n如果参数为空（或者为undefined和null），Object()返回一个空对象。\nvar obj = Object();// 等同于var obj = Object(undefined);var obj = Object(null);obj instanceof Object // true\n\n上面代码的含义，是将undefined和null转为对象，结果得到了一个空对象obj。\ninstanceof运算符用来验证，一个对象是否为指定的构造函数的实例。obj instanceof Object返回true，就表示obj对象是Object的实例。\n如果参数是原始类型的值，Object方法将其转为对应的包装对象的实例（参见《原始类型的包装对象》一章）。\nvar obj = Object(1);obj instanceof Object // trueobj instanceof Number // truevar obj = Object(&#x27;foo&#x27;);obj instanceof Object // trueobj instanceof String // truevar obj = Object(true);obj instanceof Object // trueobj instanceof Boolean // true\n\n上面代码中，Object函数的参数是各种原始类型的值，转换成对象就是原始类型值对应的包装对象。\n如果Object方法的参数是一个对象，它总是返回该对象，即不用转换。\nvar arr = [];var obj = Object(arr); // 返回原数组obj === arr // truevar value = &#123;&#125;;var obj = Object(value) // 返回原对象obj === value // truevar fn = function () &#123;&#125;;var obj = Object(fn); // 返回原函数obj === fn // true\n\n利用这一点，可以写一个判断变量是否为对象的函数。\nfunction isObject(value) &#123;  return value === Object(value);&#125;isObject([]) // trueisObject(true) // false\n\nObject 构造函数Object不仅可以当作工具函数使用，还可以当作构造函数使用，即前面可以使用new命令。\nObject构造函数的首要用途，是直接通过它来生成新对象。\nvar obj = new Object();\n\n\n注意，通过var obj = new Object()的写法生成新对象，与字面量的写法var obj = &#123;&#125;是等价的。或者说，后者只是前者的一种简便写法。\n\nObject构造函数的用法与工具方法很相似，几乎一模一样。使用时，可以接受一个参数，如果该参数是一个对象，则直接返回这个对象；如果是一个原始类型的值，则返回该值对应的包装对象（详见《包装对象》一章）。\nvar o1 = &#123;a: 1&#125;;var o2 = new Object(o1);o1 === o2 // truevar obj = new Object(123);obj instanceof Number // true\n\n虽然用法相似，但是Object(value)与new Object(value)两者的语义是不同的，Object(value)表示将value转成一个对象，new Object(value)则表示新生成一个对象，它的值是value。\nObject 的静态方法所谓“静态方法”，是指部署在Object对象自身的方法。\nObject.keys()，Object.getOwnPropertyNames()Object.keys方法和Object.getOwnPropertyNames方法都用来遍历对象的属性。\nObject.keys方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名。\nvar obj = &#123;  p1: 123,  p2: 456&#125;;Object.keys(obj) // [&quot;p1&quot;, &quot;p2&quot;]\n\nObject.getOwnPropertyNames方法与Object.keys类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。\nvar obj = &#123;  p1: 123,  p2: 456&#125;;Object.getOwnPropertyNames(obj) // [&quot;p1&quot;, &quot;p2&quot;]\n\n对于一般的对象来说，Object.keys()和Object.getOwnPropertyNames()返回的结果是一样的。只有涉及不可枚举属性时，才会有不一样的结果。Object.keys方法只返回可枚举的属性（详见《对象属性的描述对象》一章），Object.getOwnPropertyNames方法还返回不可枚举的属性名。\nvar a = [&#x27;Hello&#x27;, &#x27;World&#x27;];Object.keys(a) // [&quot;0&quot;, &quot;1&quot;]Object.getOwnPropertyNames(a) // [&quot;0&quot;, &quot;1&quot;, &quot;length&quot;]\n\n上面代码中，数组的length属性是不可枚举的属性，所以只出现在Object.getOwnPropertyNames方法的返回结果中。\n由于 JavaScript 没有提供计算对象属性个数的方法，所以可以用这两个方法代替。\nvar obj = &#123;  p1: 123,  p2: 456&#125;;Object.keys(obj).length // 2Object.getOwnPropertyNames(obj).length // 2\n\n一般情况下，几乎总是使用Object.keys方法，遍历对象的属性。\n其他方法除了上面提到的两个方法，Object还有不少其他静态方法，将在后文逐一详细介绍。\n（1）对象属性模型的相关方法\n\nObject.getOwnPropertyDescriptor()：获取某个属性的描述对象。\nObject.defineProperty()：通过描述对象，定义某个属性。\nObject.defineProperties()：通过描述对象，定义多个属性。\n\n（2）控制对象状态的方法\n\nObject.preventExtensions()：防止对象扩展。\nObject.isExtensible()：判断对象是否可扩展。\nObject.seal()：禁止对象配置。\nObject.isSealed()：判断一个对象是否可配置。\nObject.freeze()：冻结一个对象。\nObject.isFrozen()：判断一个对象是否被冻结。\n\n（3）原型链相关方法\n\nObject.create()：该方法可以指定原型对象和属性，返回一个新的对象。\nObject.getPrototypeOf()：获取对象的Prototype对象。\n\nObject 的实例方法除了静态方法，还有不少方法定义在Object.prototype对象。它们称为实例方法，所有Object的实例对象都继承了这些方法。\nObject实例对象的方法，主要有以下六个。\n\nObject.prototype.valueOf()：返回当前对象对应的值。\nObject.prototype.toString()：返回当前对象对应的字符串形式。\nObject.prototype.toLocaleString()：返回当前对象对应的本地字符串形式。\nObject.prototype.hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。\nObject.prototype.isPrototypeOf()：判断当前对象是否为另一个对象的原型。\nObject.prototype.propertyIsEnumerable()：判断某个属性是否可枚举。\n\n本节介绍前四个方法，另外两个方法将在后文相关章节介绍。\nObject.prototype.valueOf()valueOf方法的作用是返回一个对象的“值”，默认情况下返回对象本身。\nvar obj = new Object();obj.valueOf() === obj // true\n\n上面代码比较obj.valueOf()与obj本身，两者是一样的。\nvalueOf方法的主要用途是，JavaScript 自动类型转换时会默认调用这个方法（详见《数据类型转换》一章）。\nvar obj = new Object();1 + obj // &quot;1[object Object]&quot;\n\n上面代码将对象obj与数字1相加，这时 JavaScript 就会默认调用valueOf()方法，求出obj的值再与1相加。所以，如果自定义valueOf方法，就可以得到想要的结果。\nvar obj = new Object();obj.valueOf = function () &#123;  return 2;&#125;;1 + obj // 3\n\n上面代码自定义了obj对象的valueOf方法，于是1 + obj就得到了3。这种方法就相当于用自定义的obj.valueOf，覆盖Object.prototype.valueOf。\nObject.prototype.toString()toString方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串。\nvar o1 = new Object();o1.toString() // &quot;[object Object]&quot;var o2 = &#123;a:1&#125;;o2.toString() // &quot;[object Object]&quot;\n\n上面代码表示，对于一个对象调用toString方法，会返回字符串[object Object]，该字符串说明对象的类型。\n字符串[object Object]本身没有太大的用处，但是通过自定义toString方法，可以让对象在自动类型转换时，得到想要的字符串形式。\nvar obj = new Object();obj.toString = function () &#123;  return &#x27;hello&#x27;;&#125;;obj + &#x27; &#x27; + &#x27;world&#x27; // &quot;hello world&quot;\n\n上面代码表示，当对象用于字符串加法时，会自动调用toString方法。由于自定义了toString方法，所以返回字符串hello world。\n数组、字符串、函数、Date 对象都分别部署了自定义的toString方法，覆盖了Object.prototype.toString方法。\n[1, 2, 3].toString() // &quot;1,2,3&quot;&#x27;123&#x27;.toString() // &quot;123&quot;(function () &#123;  return 123;&#125;).toString()// &quot;function () &#123;//   return 123;// &#125;&quot;(new Date()).toString()// &quot;Tue May 10 2016 09:11:31 GMT+0800 (CST)&quot;\n\n上面代码中，数组、字符串、函数、Date 对象调用toString方法，并不会返回[object Object]，因为它们都自定义了toString方法，覆盖原始方法。\ntoString() 的应用：判断数据类型Object.prototype.toString方法返回对象的类型字符串，因此可以用来判断一个值的类型。\nvar obj = &#123;&#125;;obj.toString() // &quot;[object Object]&quot;\n\n上面代码调用空对象的toString方法，结果返回一个字符串object Object，其中第二个Object表示该值的构造函数。这是一个十分有用的判断数据类型的方法。\n由于实例对象可能会自定义toString方法，覆盖掉Object.prototype.toString方法，所以为了得到类型字符串，最好直接使用Object.prototype.toString方法。通过函数的call方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型。\nObject.prototype.toString.call(value)\n\n上面代码表示对value这个值调用Object.prototype.toString方法。\n不同数据类型的Object.prototype.toString方法返回值如下。\n\n数值：返回[object Number]。\n字符串：返回[object String]。\n布尔值：返回[object Boolean]。\nundefined：返回[object Undefined]。\nnull：返回[object Null]。\n数组：返回[object Array]。\narguments 对象：返回[object Arguments]。\n函数：返回[object Function]。\nError 对象：返回[object Error]。\nDate 对象：返回[object Date]。\nRegExp 对象：返回[object RegExp]。\n其他对象：返回[object Object]。\n\n这就是说，Object.prototype.toString可以看出一个值到底是什么类型。\nObject.prototype.toString.call(2) // &quot;[object Number]&quot;Object.prototype.toString.call(&#x27;&#x27;) // &quot;[object String]&quot;Object.prototype.toString.call(true) // &quot;[object Boolean]&quot;Object.prototype.toString.call(undefined) // &quot;[object Undefined]&quot;Object.prototype.toString.call(null) // &quot;[object Null]&quot;Object.prototype.toString.call(Math) // &quot;[object Math]&quot;Object.prototype.toString.call(&#123;&#125;) // &quot;[object Object]&quot;Object.prototype.toString.call([]) // &quot;[object Array]&quot;\n\n利用这个特性，可以写出一个比typeof运算符更准确的类型判断函数。\nvar type = function (o)&#123;  var s = Object.prototype.toString.call(o);  return s.match(/\\[object (.*?)\\]/)[1].toLowerCase();&#125;;type(&#123;&#125;); // &quot;object&quot;type([]); // &quot;array&quot;type(5); // &quot;number&quot;type(null); // &quot;null&quot;type(); // &quot;undefined&quot;type(/abcd/); // &quot;regex&quot;type(new Date()); // &quot;date&quot;\n\n在上面这个type函数的基础上，还可以加上专门判断某种类型数据的方法。\nvar type = function (o)&#123;  var s = Object.prototype.toString.call(o);  return s.match(/\\[object (.*?)\\]/)[1].toLowerCase();&#125;;[&#x27;Null&#x27;, &#x27;Undefined&#x27;, &#x27;Object&#x27;, &#x27;Array&#x27;, &#x27;String&#x27;, &#x27;Number&#x27;, &#x27;Boolean&#x27;, &#x27;Function&#x27;, &#x27;RegExp&#x27;].forEach(function (t) &#123;  type[&#x27;is&#x27; + t] = function (o) &#123;    return type(o) === t.toLowerCase();  &#125;;&#125;);type.isObject(&#123;&#125;) // truetype.isNumber(NaN) // truetype.isRegExp(/abc/) // true\n\nObject.prototype.toLocaleString()Object.prototype.toLocaleString方法与toString的返回结果相同，也是返回一个值的字符串形式。\nvar obj = &#123;&#125;;obj.toString(obj) // &quot;[object Object]&quot;obj.toLocaleString(obj) // &quot;[object Object]&quot;\n\n这个方法的主要作用是留出一个接口，让各种不同的对象实现自己版本的toLocaleString，用来返回针对某些地域的特定的值。\nvar person = &#123;  toString: function () &#123;    return &#x27;Henry Norman Bethune&#x27;;  &#125;,  toLocaleString: function () &#123;    return &#x27;白求恩&#x27;;  &#125;&#125;;person.toString() // Henry Norman Bethuneperson.toLocaleString() // 白求恩\n\n上面代码中，toString()方法返回对象的一般字符串形式，toLocaleString()方法返回本地的字符串形式。\n目前，主要有三个对象自定义了toLocaleString方法。\n\nArray.prototype.toLocaleString()\nNumber.prototype.toLocaleString()\nDate.prototype.toLocaleString()\n\n举例来说，日期的实例对象的toString和toLocaleString返回值就不一样，而且toLocaleString的返回值跟用户设定的所在地域相关。\nvar date = new Date();date.toString() // &quot;Tue Jan 01 2018 12:01:33 GMT+0800 (CST)&quot;date.toLocaleString() // &quot;1/01/2018, 12:01:33 PM&quot;\n\nObject.prototype.hasOwnProperty()Object.prototype.hasOwnProperty方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。\nvar obj = &#123;  p: 123&#125;;obj.hasOwnProperty(&#x27;p&#x27;) // trueobj.hasOwnProperty(&#x27;toString&#x27;) // false\n\n上面代码中，对象obj自身具有p属性，所以返回true。toString属性是继承的，所以返回false。\n参考链接\nAxel Rauschmayer, Protecting objects in JavaScript\nkangax, Understanding delete\nJon Bretman, Type Checking in JavaScript\nCody Lindley, Thinking About ECMAScript 5 Parts\nBjorn Tipling, Advanced objects in JavaScript\nJavier Márquez, JavaScript properties are enumerable, writable and configurable\nSella Rafaeli, Native JavaScript Data-Binding: 使用存取函数实现model与view的双向绑定\nLea Verou, Copying object properties, the robust way\n\n\n未完待续\n","tags":["教程","JavaScript"]},{"title":"从零开始学JavaScript（021 Object 对象）","url":"/2023/08/30/js021/","content":"JavaScript 原生提供Object对象（注意起首的O是大写），本章介绍该对象原生的各种方法。\n","tags":["教程","JavaScript"]},{"title":"在哔站上看到了些有用的github项目，这里整理分享一下","url":"/2023/08/05/youyon/","content":"那些非常实用的github项目，总有你能用上的（持续更新中）\n\n第一波\n手把手指导你写垃圾代码！从入门到精通！ https://github.com/trekhleb/state-of-the-art-shitcode/blob/master/README.zh-CN.md备用：https://kgithub.com/trekhleb/state-of-the-art-shitcode/blob/master/README.zh-CN.md\n\nPyDebloatX、一键卸载 Windows 默认程序https://github.com/Teraskull/PyDebloatX备用：https://kgithub.com/Teraskull/PyDebloatX\n\nCarbon、源码转图片https://github.com/carbon-app/carbon备用：https://kgithub.com/carbon-app/carbon\n\nAlist、存储聚合https://github.com/alist-org/alist备用：https://kgithub.com/alist-org/alist\n\nFinancialSupportForOpenSource、开源挣钱手册https://github.com/wizicer/FinancialSupportForOpenSource备用：https://kgithub.com/wizicer/FinancialSupportForOpenSource\n\nAutoCut、通过字幕剪视频https://github.com/mli/autocut备用：https://kgithub.com/mli/autocut\n\n\nWindows直接使用的版本：https://github.com/zcf0508/autocut\n\nImage-to-Braille、图片转字符https://github.com/505e06b2/Image-to-Braille备用：https://kgithub.com/505e06b2/Image-to-Braille\n\n体验网址：https://505e06b2.github.io/Image-to-Braille/\n\nNotion风格头像https://github.com/Mayandev/notion-avatar备用：https://kgithub.com/Mayandev/notion-avatar\n\nMagic-Copy、浏览器快速抠图插件https://github.com/kevmo314/magic-copy备用：https://kgithub.com/kevmo314/magic-copy\n\nReference、代码速查表https://github.com/jaywcjlove/reference备用：https://kgithub.com/jaywcjlove/reference\n\n\n第二波一、Distro chooser 帮你选择发行版系统 https://github.com/distrochooser/distrochooser体验地址：distrochooser.de\n二、Emoji Mix 各种emoji表情合成https://github.com/Tikolu/emojimix体验地址：https://tikolu.net/emojimix\n三、Emoji-to-scale emoji表情大小可视化https://github.com/javierbyte/emoji-to-scale体验地址：https://javier.xyz/emoji-to-scale\n四、Ventoy 用于制作修复系统的u盘https://github.com/ventoy/Ventoy官网：www.ventoy.net\n五、Krita 一款开源免费的绘图软件（支持Win、Mac、Linux）https://github.com/KDE/krita官网：https://krita.org/zh/\n六、lively 一款动态壁纸软件https://github.com/rocksdanister/lively官网：rocksdanister.com&#x2F;lively\n壁纸下载：https://mylivewallpapers.com/livewallp：https://livewallp.com/致美化-动态壁纸：https://zhutix.com/animated/来自异次元软件世界：50 个惊艳的免费动态桌面壁纸 MP4 视频合集打包下载https://www.iplaysoft.com/50-live-wallpapers-mp4.html\n七、PDFPatcher 一款功能性十分强大的pdf处理工具https://github.com/wmjordan/PDFPatcher官网：pdfpatcher.cnblogs.com\n第三波一、AI绘画整合包、作者更新地址 https://pan.baidu.com/s/1_ibEk2OpKHxmEg4AnFOpSA提取码：b145来自：https://www.bilibili.com/video/BV1iM4y1y7oA/\n二、Star-History 显示star数据的增长曲线https://github.com/star-history/star-history体验地址：https://star-history.com/\n三、Socialify 在分享项目时生成小卡片https://github.com/wei/socialify体验地址：http://socialify.git.ci/\n四、Quick Cut 快速编辑视频，集成了多种功能https://github.com/HaujetZhao/QuickCut\n五、搜索替换工具https://github.com/Summer-andy/chrome-extensions-searchReplace\n六、EverythingToolbar 将everything集成进了系统搜索https://github.com/srwi/EverythingToolbar果核分流：https://www.ghxi.com/everythingtoolbar.html\nIbEverythingExthttps://github.com/Chaoses-Ib/IbEverythingExt\n七、隐形水印工具https://github.com/guofei9987/blind_watermark\n第四波待更新……\n希望这些有用的github项目能帮到各位。\n","tags":["github"]},{"title":"PS PR AU AE 等软件下载（Win|Mac）","url":"/2023/08/03/%E6%9D%82%E8%B0%88803/","content":"有没有那么一个瞬间，你好想剪几个视频玩玩？有没有那么一个时候，你急需掌握PS这项技能？想的再多，不如付之行动，下载，便是第一步。\n\n\n看看你的 | can can need有道是技多不压身，多一项技能，在未来的职场路上，总归是能发挥一些用处的。开头直接丢链接，请拿好。（所有涉及的解压密码均为：lantongxue）\n百度网盘：Adobe全家桶\nPS PR AU AE 简介PSps是Adobe Photoshop的缩写，是一款非常强大的数字图像处理软件，可用于日常照片的美化，在广告摄影、平面设计、文字排版、影像创意、网页制作等领域都发挥着重要作用。\nPRpr的全称是Adobe Premiere，是一款常用的视频编辑软件，是视频编辑爱好者和专业人士必不可少的视频编辑工具，是一款易学、高效、精确的视频剪辑软件。\nAEae的全称是After Effect，是一个视频剪辑及设计软件，是制作动态影像设计不可或缺的辅助工具，其应用范围涵盖影片、电影、广告、多媒体等，包括一些流行的游戏都是由它进行合成制作。\nAUau的全称是Adobe Audition，是一款专业的音乐录制、制作软件，能很方便的对音频文件进行修改、合并，支持128条音轨、多种音频格式、多种音频的特效，操作起来简单方便。\n","tags":["杂谈"]},{"title":"这个博客依旧在更新","url":"/2023/10/04/%E5%AD%98%E6%B4%BB%E7%A1%AE%E8%AE%A4/","content":"很难想象开学之后有这么多破事，以前日更的博客，现在也逐渐变成月更了，没有办法。\n\n碎碎念这是一条碎碎念然后没了\n","tags":["博客"]},{"title":"神秘复苏读后感","url":"/2023/08/03/shenmi/","content":"这几天把神秘复苏给看完了，内心多少还是有些感触，和大伙唠唠\n\n\n人间如狱作为神秘复苏的第一版书名，这个名字才更加贴合书中的世界观。\n鬼是无法被杀死的\n只有鬼才能对抗鬼 \n要洞悉厉鬼的规律\n这三条定律，奠定了前期的绝望氛围，驭鬼者每驾驭一只厉鬼，身上的负担就会更加重一份，灵异力量无时无刻不在侵蚀驭鬼者的身心，而且令人绝望的是，这种侵蚀几乎是不可逆的。\n要说驭鬼者如果只用对付鬼怪，那也就罢了。\n但事实是，在驭鬼者林立的社会里，有些人，比厉鬼还要可怕，他们为了利益，全然不顾厉鬼复苏的后果，往往为了一点蝇头小利，他们就会留下许多灵异事件，将道不同不相为谋的驭鬼者逼入绝境。\n而本书的主角阳间，也正是在一次次与厉鬼的对抗中成长，最后应召成为了总部的“鬼眼”刑警。（腿哥yyds）\n恐怖复苏本书连载到中期时，大净网时代也到来了。\n从本人编排文字的这个时间点往回看，我不太想评论太多，因为这场声势浩大的净网行动是由多部门发起的，别说一个起点，就算是全网的网络平台加起来，也是难以对抗。\n净网时代陨落了无数神作，有的再无音讯，有的改名重生。\n《恐怖复苏》就属于后者。\n大纲一改再改，鬼手的剧情被砍，恐怖刺青馆剧情被砍，鬼新娘剧情也被砍……\n也难怪作者会心态爆炸，这换谁，谁能不迷糊呢？\n神秘复苏如果你以为改一次名字就可以躲过一劫，那么我这蓝银缠绕2.0，阁下又该如何应对？\n没有错，在某不知名群体的举报下，本书再次改名，从《恐怖复苏》改成了《神秘复苏》，硬生生从灵异改成了仙侠。\n作者傻了，读者傻了，但是有什么办法呢，蒸馍，你不服气？\n小说剧情由此走向无敌文，主角越来越向神话里的杨戬靠拢。\n三眼，大狗，该有的都有。\n不知不觉间，阳间早已站在驭鬼者的巅峰。\n甚至在面对民国七老，他也能从容应对。\n还是那句话，让张洞来.jpg\n当然，后面的剧情确实有些快了，鬼邮局和鬼宅着两个剧情巅峰过后，就是被很多人诟病的国战情节，幽灵船写的也是有些潦草，主角并非MVP，最后击杀大boss的还是洞天帝。\n此处省略几百字。\n大结局里，主角独断灵异时代六十年。\n待他再次“苏醒”时，说不清是阳间还是鬼童的存在，言语中竟透露着神性。\n或许真的如王珊珊所言，现在的阳间，已经变成了杨戬…一尊为终结灵异时代而诞生的神明。\n\n省流速读知乎用户杞鋂的总结非常到位，这里建议大家前去观阅。\n神秘复苏省流版: 全文精读分析《神秘复苏》主线故事\n","tags":["网络小说","观后感"]}]